<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The LibAFL Fuzzing Library</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="libafl.html">The LibAFL Fuzzing Library</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting_started/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="getting_started/build.html"><strong aria-hidden="true">1.2.</strong> Build</a></li><li class="chapter-item expanded "><a href="getting_started/crates.html"><strong aria-hidden="true">1.3.</strong> Crates</a></li></ol></li><li class="chapter-item expanded "><a href="baby_fuzzer.html"><strong aria-hidden="true">2.</strong> Baby Fuzzer</a></li><li class="chapter-item expanded "><a href="design/design.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/core_concepts.html"><strong aria-hidden="true">3.1.</strong> Core Concepts</a></li><li class="chapter-item expanded "><a href="design/architecture.html"><strong aria-hidden="true">3.2.</strong> Architecture</a></li></ol></li><li class="chapter-item expanded "><a href="medatata/metadata.html"><strong aria-hidden="true">4.</strong> Understanding Metadata</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="medatata/definition.html"><strong aria-hidden="true">4.1.</strong> Definition</a></li><li class="chapter-item expanded "><a href="medatata/de_serialization.html"><strong aria-hidden="true">4.2.</strong> (De)Serialization</a></li><li class="chapter-item expanded "><a href="medatata/usage.html"><strong aria-hidden="true">4.3.</strong> Usage</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The LibAFL Fuzzing Library</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-libafl-fuzzing-library"><a class="header" href="#the-libafl-fuzzing-library">The LibAFL Fuzzing Library</a></h1>
<p><em>by Andrea Fioraldi and Dominik Maier</em></p>
<p>This version of the LibAFL book is coupled with the release 1.0 beta of the library.</p>
<p>This document is still work-in-progress and incomplete. The structure and the concepts explained here are subject to change in future revisions, as the structure of LibAFL itself will evolve.</p>
<p>The HTML version of this book is available online at https://aflplus.plus/libafl-book/ and offline from the LibAFL repository in the docs/ folder.</p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Fuzzers are important assets in the pockets of security researchers and developers alike.
A wide range of cool state-of-the-art tools like <a href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a>, <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a> or <a href="https://github.com/google/honggfuzz">honggfuzz</a> are available to users. They do their job in a very effective way, finding thousands of bugs.</p>
<p>From the power user perspective, however, these tools are limited.
Their design does not treat extensibility as a first-class citizen.
Usually, a fuzzer developer can choose to either fork one of these existing tools, or to create a new fuzzer from scratch.
In any case, researchers end up with tons of fuzzers, all of which are incompatible with each other.
Their outstanding features can not just be combined for new projects.
Instead, we keep reinventing the wheel and may completely miss out on features that are complex to reimplement.</p>
<p>Here comes LibAFL, a library that IS NOT a fuzzer, but a collection of reusable pieces of fuzzers, written in Rust.
LibAFL helps you develop your own custom fuzzer, tailored for your specific needs.
Be it a specific target, a particular instrumentation backend, or a custom mutator, you can leverage existing bits and pieces to craft the fastest and most efficient fuzzer you can envision.</p>
<h2 id="why-libafl"><a class="header" href="#why-libafl">Why LibAFL?</a></h2>
<p>LibAFL gives you many of the benefits of an off-the-shelf fuzzer, while being completely customizable.
Some highlight features currently include:</p>
<ul>
<li><code>multi platform</code>: LibAFL works pretty much anywhere you can find a Rust compiler for. We already used it on <em>Windows</em>, <em>Android</em>, <em>MacOS</em>, and <em>Linux</em>, on <em>x86_64</em>, <em>aarch64</em>, ...</li>
<li><code>portable</code>: <code>LibAFL</code> can be built in <code>no_std</code> mode. This means it does not require a specific OS-dependent runtime to function. Define an allocator and a way to map pages, you should be good to inject LibAFL in obscure targets like embedded devices, hypervisors, or maybe even WebAssembly?</li>
<li><code>adaptable</code>: Given year of experience fine-tuning <em>AFLplusplus</em> and our academic fuzzing background, we could incorporate recent fuzzing trends into LibAFL's deign and make it future-proof.
To give an example, as opposed to old-skool fuzzers, a <code>BytesInput</code> is just one of the potential forms of inputs:
feel free to use and mutate an Abstract Syntax Tree instead, for structured fuzzing.</li>
<li><code>scalable</code>: As part of LibAFL, we developed <code>Low Level Message Passing</code>, <code>LLMP</code> for short, which allows LibAFL to scale almost linearly over cores. That is, if you chose to use this feature - it is your fuzzer, after all. Scaling to multiple machines over TCP is on the near road-map.</li>
<li><code>fast</code>: We do everything we can at compiletime so that the runtime overhead is as minimal as it can get.</li>
<li><code>bring your own target</code>: We support binary-only modes, like Frida-Mode with ASAN and CmpLog, as well as multiple compilation passes for sourced-based instrumentation, and of course support custom instrumentation.</li>
<li><code>usable</code>: This one is on you to decide. Dig right in!</li>
</ul>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To start using LibAFL, there are some first steps to do. In this chapter, we will
discuss how to download LibAFL and build with <code>cargo</code>, how are structured its crates and the purpose of each crate.</p>
<h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>The first step is to download LibAFL and all its dependencies that are not automatically installed with <code>cargo</code>.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>In this chapter and throughout the book, we’ll show some commands used in the
terminal. Lines that you should enter in a terminal all start with <code>$</code>. You
don’t need to type in the <code>$</code> character; it indicates the start of each
command. Lines that don’t start with <code>$</code> typically show the output of the
previous command. Additionally, PowerShell-specific examples will use <code>&gt;</code>
rather than <code>$</code>.</p>
</blockquote>
<p>The easiest way to download LibAFL is using <code>git</code>.</p>
<pre><code class="language-sh">$ git clone git@github.com:AFLplusplus/LibAFL.git
</code></pre>
<p>You can alternatively, on a UNIX-like machine, download a compressed archive and extract with:</p>
<pre><code class="language-sh">$ wget https://github.com/AFLplusplus/LibAFL/archive/main.tar.gz
$ tar xvf LibAFL-main.tar.gz
$ rm LibAFL-main.tar.gz
$ ls LibAFL-main # this is the extracted folder
</code></pre>
<h2 id="clang-installation"><a class="header" href="#clang-installation">Clang installation</a></h2>
<p>One of the external dependencies of LibAFL is the Clang C/C++ compiler.
While most of the code is in pure Rust, we still need a C compiler because Rust stable
still does not support features that we need such as weak linking and LLVM builtins linking,
and so we use C to expose the missing functionalities to our Rust codebase.</p>
<p>In addition, if you want to perform source-level fuzz testing of C/C++ applications,
you will likely need Clang with its instrumentation options to compile the programs
under test.</p>
<p>On Linux you can use your distro's package manager to get Clang,
but these packages are not always updated, so we suggest you to use the
Debian/Ubuntu prebuilt packages from LLVM that are available using their <a href="https://apt.llvm.org/">official repository</a>.</p>
<p>For Microsoft Windows, you can download the <a href="https://llvm.org/builds/">installer package</a> that LLVM generates periodically.</p>
<p>Despite that Clang is the default C compiler on macOS, we discourage the use of the build shipped by Apple and encourage
the installation from <code>brew</code> or directly a fresh build from the source code.</p>
<p>Alternatively you can download and build the LLVM source tree - Clang included - following the steps
explained <a href="https://clang.llvm.org/get_started.html">here</a>.</p>
<h2 id="rust-installation"><a class="header" href="#rust-installation">Rust installation</a></h2>
<p>If you don't have Rust installed, you can easily follow the steps described <a href="https://www.rust-lang.org/tools/install">here</a>
to install it on any supported system.</p>
<p>We suggest to install Clang and LLVM first.</p>
<h1 id="build"><a class="header" href="#build">Build</a></h1>
<p>LibAFL, as most of the Rust projects, can be built using <code>cargo</code> from the root directory of the project with:</p>
<pre><code class="language-sh">$ cargo build --release
</code></pre>
<p>Note that the <code>--release</code> flag is optional for development, but you needed to add it to fuzzing at a decent speed.
Slowdowns of 10x or more are not uncommon for Debug builds.</p>
<p>The LibAFL repository is composed of multiple crates.
The top-level Cargo.toml is the workspace file grouping these crates.
Calling <code>cargo build</code> from the root directory will compile all crates in the workspace.</p>
<h2 id="build-example-fuzzers"><a class="header" href="#build-example-fuzzers">Build Example Fuzzers</a></h2>
<p>We group example fuzzers in the <code>./fuzzers</code> directory of the LibAFL repository.
The directory contains a set of crates that are not part of the workspace.</p>
<p>Each of these example fuzzers uses particular features of LibAFL, sometimes combined with different instrumentation backends (e.g. <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>, <a href="https://frida.re/">Frida</a>, ...).</p>
<p>You can use these crates as examples and as skeletons for custom fuzzers with similar feature sets.</p>
<p>To build an example fuzzer you have to invoke cargo from its respective folder (<code>fuzzers/[FUZZER_NAME]</code>).</p>
<h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>LibAFL is composed by different crates.
Each one has its self-contained purpose, and the user may not need to use all of them in its project.</p>
<p>Following the naming convention of the folders in the project's root, they are:</p>
<h3 id="libafl"><a class="header" href="#libafl">libafl</a></h3>
<p>This is the main crate that contains all the components needed to build a fuzzer.</p>
<p>This crate has the following feature flags:</p>
<ul>
<li>std, that enables the parts of the code that use the Rust standard library. Without this flag, libafl is no_std.</li>
<li>derive, that enables the usage of the <code>derive(...)</code> macros defined in libafl_derive from libafl.</li>
</ul>
<p>By default, std and derive are both set.</p>
<h3 id="libafl_derive"><a class="header" href="#libafl_derive">libafl_derive</a></h3>
<p>This a proc-macro crate paired with the libafl crate.</p>
<p>At the moment, it just expose the <code>derive(SerdeAny)</code> macro that can be used to define metadata structs.</p>
<h3 id="libafl_targets"><a class="header" href="#libafl_targets">libafl_targets</a></h3>
<p>This crate that exposes, under feature flags, pieces of code to interact with targets</p>
<p>Currently, the supported flags are:</p>
<ul>
<li>pcguard_edges, that defines the SanitizerCoverage trace-pc-guard hooks to track the executed edges in a map.</li>
<li>pcguard_hitcounts, that defines the SanitizerCoverage trace-pc-guard hooks to track the executed edges with the hitcounts (like AFL) in a map.</li>
<li>libfuzzer, that expose a compatibility layer with libFuzzer style harnesses.</li>
<li>value_profile, that defines the SanitizerCoverage trace-cmp hooks to track the matching bits of each comparison in a map. </li>
</ul>
<h3 id="libafl_cc"><a class="header" href="#libafl_cc">libafl_cc</a></h3>
<p>This is a library that provides some utils to wrap compilers and create source level fuzzers.</p>
<p>At the moment, only the Clang compiler is supported.</p>
<h1 id="baby-fuzzer"><a class="header" href="#baby-fuzzer">Baby Fuzzer</a></h1>
<p>This chapter will teach you how to create a naive fuzzer using the LibAFL API, you will learn about basic entities such as <code>State</code>, <code>Observer</code>, and <code>Executor</code>.
The following chapters will discuss in detail the components of LibAFL, while here we will just scratch the fundamentals.</p>
<p>We are going to fuzz a simple Rust function that panics under a condition. The fuzzer will be single-threaded and will stop after the crash like libFuzzer does normally.</p>
<p>You can find a complete version of this tutorial as an example fuzzer in <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/baby_fuzzer"><code>fuzzers/baby_fuzzer</code></a>.</p>
<h2 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h2>
<p>We use cargo to create a new Rust project with LibAFL as a dependency. </p>
<pre><code class="language-sh">$ cargo new baby_fuzzer
$ cd baby_fuzzer
</code></pre>
<p>The generated <em>Cargo.toml</em> looks like the following:</p>
<pre><code class="language-toml">[package]
name = &quot;baby_fuzzer&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>In order to use LibAFl we must add it as dependency adding <code>libafl = { path = &quot;path/to/libafl/&quot; }</code> under <code>[dependencies]</code>.
You can use the LibAFL version from crates.io if you want, in this case, you have to use <code>libafl = &quot;*&quot;</code> to get the latest version.</p>
<p>As we are going to fuzz Rust code, we want that a panic does not simply cause the program exit, but an abort that can be caught by the fuzzer.
To do that, we specify <code>panic = &quot;abort&quot;</code> in the <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">profiles</a>.</p>
<p>Alongside this setting, we add some optimization flags for the compile when building in release mode.</p>
<p>The final <em>Cargo.toml</em> should look similar to the following:</p>
<pre><code class="language-toml">[package]
name = &quot;baby_fuzzer&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
libafl = { path = &quot;path/to/libafl/&quot; }

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
lto = true
codegen-units = 1
opt-level = 3
debug = true
</code></pre>
<h2 id="the-function-under-test"><a class="header" href="#the-function-under-test">The function under test</a></h2>
<p>Opening <code>src/main.rs</code> we have an empty main function.
To start, we create the closure that we want to fuzz. It takes a buffer as input and panics if it starts with &quot;abc&quot;.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut harness = |buf: &amp;[u8]| {
    if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
        if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
            if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
                panic!(&quot;=)&quot;);
            }
        }
    }
};
// To test the panic:
// let input = &quot;abc&quot;.as_bytes();
// harness(&amp;input);
<span class="boring">}
</span></code></pre></pre>
<h2 id="generating-and-running-some-tests"><a class="header" href="#generating-and-running-some-tests">Generating and running some tests</a></h2>
<p>One of the main components that a LibAFL-based fuzzer uses is the State, a container of the data that is evolved during the fuzzing process, such as the Corpus of inputs.
In our main so we create a basic State instance like the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create a State from scratch
let mut state = State::new(
    // RNG
    StdRand::with_seed(current_nanos()),
    // Corpus that will be evolved, we keep it in memory for performance
    InMemoryCorpus::new(),
    (),
    // Corpus in which we store solutions (crashes in this example),
    // on disk so the user can get them after stopping the fuzzer
    OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
    (),
);
<span class="boring">}
</span></code></pre></pre>
<p>It takes a random number generator, that is part of the fuzzer state, in this case, we use the default one <code>StdRand</code> but you can choose a different one. We seed it with the current nanoseconds.</p>
<p>As the second parameter, it takes an instance of something implementing the Corpus trait, InMemoryCorpus in this case. The corpus is the container of the testcases evolved by the fuzzer, in this case, we keep it all in memory.</p>
<p>We will discuss later the third and fifth parameters. The fourth is another corpus, in this case, to store the testcases that are considered as &quot;solutions&quot; for the fuzzer. For our purpose, the solution is the input that triggers the panic. In this case, we want to store it to disk under the <code>crashes</code> directory so we can inspect it.</p>
<p>Another required component is the EventManager. It handles some events such as the addition of a testcase to the corpus during the fuzzing process. For our purpose, we use the simplest one that just displays the information about these events to the user using a Stats instance.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The Stats trait define how the fuzzer stats are reported to the user
let stats = SimpleStats::new(|s| println!(&quot;{}&quot;, s));

// The event manager handle the various events generated during the fuzzing loop
// such as the notification of the addition of a new item to the corpus
let mut mgr = SimpleEventManager::new(stats);
<span class="boring">}
</span></code></pre></pre>
<p>Last but not least, we need an Executor that is the entity responsible to run our program under test. In this example, we want to run the harness function in process, and so we use the InProcessExecutor.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create the executor for an in-process function
let mut executor =
    InProcessExecutor::new(&amp;mut harness, (), &amp;mut state, &amp;mut mgr)
        .expect(&quot;Failed to create the Executor&quot;.into());
<span class="boring">}
</span></code></pre></pre>
<p>It takes a reference to the harness, the state, and the event manager. We will discuss the second parameter later.
As the executor expects that the harness returns an ExitKind object, we add <code>ExitKind::Ok</code> to our harness function.</p>
<p>Now we have the 3 major entities ready for running our tests, but we still cannot generate testcases.</p>
<p>For this purpose, we use a Generator, RandPrintablesGenerator that generates a string of printable bytes.
The State's method used to generate and run tests needs a scheduling policy for the corpus. We create it as QueueCorpusScheduler, a scheduler that serves testcases to the fuzzer in a FIFO fashion.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A queue policy to get testcasess from the corpus
let scheduler = QueueCorpusScheduler::new();

// Generator of printable bytearrays of max size 32
let mut generator = RandPrintablesGenerator::new(32);

// Generate 8 initial inputs
state
    .generate_initial_inputs(&amp;mut executor, &amp;mut generator, &amp;mut mgr, &amp;scheduler, 8)
    .expect(&quot;Failed to generate the initial corpus&quot;.into());
<span class="boring">}
</span></code></pre></pre>
<p>Now you can prepend the following <code>use</code> directives to your main.rs and compile it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;
use libafl::{
    corpus::{InMemoryCorpus, OnDiskCorpus, QueueCorpusScheduler},
    events::SimpleEventManager,
    executors::{inprocess::InProcessExecutor, ExitKind},
    generators::RandPrintablesGenerator,
    state::State,
    stats::SimpleStats,
    utils::{current_nanos, StdRand},
};
<span class="boring">}
</span></code></pre></pre>
<p>When running, you should see something similar to:</p>
<pre><code class="language-sh">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/baby_fuzzer`
[LOG Debug]: Loaded 0 over 8 initial testcases
</code></pre>
<h2 id="evolving-the-corpus-with-feedbacks"><a class="header" href="#evolving-the-corpus-with-feedbacks">Evolving the corpus with feedbacks</a></h2>
<p>Now you simply ran 8 randomly generated testcases but none of them has been stored in the corpus. If you are very lucky, maybe you triggered the panic by chance but you don't see any saved file in <code>crashes</code>.</p>
<p>Now we want to turn our simple fuzzer into a feedback-based one and increase the chance to generate the right input to trigger the panic. We are going to implement a simple feedback based on the 3 conditions that are needed to reach the panic.</p>
<p>To do that, we need a way to keep track of if a condition is satisfied. The component that feeds the fuzzer with information about properties of a fuzzing run, the satisfied conditions in our case, is the Observer. We use the StdMapObserver, the default observer that uses a map to keep track of covered elements. In our fuzzer, each condition is mapped to an entry of such map.</p>
<p>We represent such map as a <code>static mut</code> variable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Coverage map with explicit assignments due to the lack of instrumentation
static mut SIGNALS: [u8; 16] = [0; 16];

fn signals_set(idx: usize) {
    unsafe { SIGNALS[idx] = 1 };
}
<span class="boring">}
</span></code></pre></pre>
<p>As we don't rely on any instrumentation engine, we have to manually track the satisfied conditions in a map modyfing our tested function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The closure that we want to fuzz
let mut harness = |buf: &amp;[u8]| {
    signals_set(0);
    if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
        signals_set(1);
        if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
            signals_set(2);
            if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
                panic!(&quot;=)&quot;);
            }
        }
    }
    ExitKind::Ok
};
<span class="boring">}
</span></code></pre></pre>
<p>The observer can be created directly from the <code>SIGNALS</code> map, in the following way:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create an observation channel using the signals map
let observer = StdMapObserver::new(&quot;signals&quot;, unsafe { &amp;mut SIGNALS });
<span class="boring">}
</span></code></pre></pre>
<p>The observers are usually kept in the corresponding executor as they keep track of information that is valid for just one run. We have then to modify our InProcessExecutor creation to include the observer as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create the executor for an in-process function with just one observer
let mut executor =
    InProcessExecutor::new(&amp;mut harness, tuple_list!(observer), &amp;mut state, &amp;mut mgr)
        .expect(&quot;Failed to create the Executor&quot;.into());
<span class="boring">}
</span></code></pre></pre>
<p>Now that the fuzzer can observe which condition is satisfied, we need a way to rate an input as interesting (i.e. worth of addition to the corpus) based on this observation. Here comes the notion of Feedback. The Feedback is part of the State and provides a way to rate input and its corresponding execution as interesting looking for the information in the observers. Feedbacks can maintain a cumulative state of the information seen so far, in our case it maintains the set of conditions satisfied in the previous runs.</p>
<p>We use MaxMapFeedback, a feedback that implements a novelty search over the map of the MapObserver. Basically, if there is a value in the observer's map that is greater than the maximum value registered so far for the same entry, it rates the input as interesting and updates its state.</p>
<p>Feedbacks are used also to decide if an input is a &quot;solution&quot;. The feedback that does that is called the Objective Feedback and when it rates an input as interested it is not saved to the corpus but to the solutions, written in the <code>crashes</code> folder in our case. We use the CrashFeedback to tell the fuzzer that if an input causes the program to crash it is a solution for us.</p>
<p>We need to update our State creation including these feedbacks:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create a State from scratch
let mut state = State::new(
    // RNG
    StdRand::with_seed(current_nanos()),
    // Corpus that will be evolved, we keep it in memory for performance
    InMemoryCorpus::new(),
    // Feedback to rate the interestingness of an input
    MaxMapFeedback::new_with_observer(&amp;observer),
    // Corpus in which we store solutions (crashes in this example),
    // on disk so the user can get them after stopping the fuzzer
    OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
    // Feedbacks to recognize an input as solution
    CrashFeedback::new(),
);
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-actual-fuzzing"><a class="header" href="#the-actual-fuzzing">The actual fuzzing</a></h2>
<p>Now, after including the correct <code>use</code>, we can run the program, but the outcome is not so different from the previous one as the random generator does not take into account what we save as interesting in the corpus. To do that, we need to plug a Mutator.</p>
<p>Another central component of LibAFL is the Fuzzer, an entity that holds a set of Stages that are actions done on individual inputs taken from the corpus. The MutationalStage mutates the input and executes it several times for instance.</p>
<p>As the last step, to have a proper fuzzer, we create a Fuzzer with a single MutationalStage that uses a mutator inspired by the havoc mutator of AFL.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Setup a basic mutator with a mutational stage
let mutator = StdScheduledMutator::new(havoc_mutations());
let stage = StdMutationalStage::new(mutator);

// A fuzzer with just one stage
let mut fuzzer = StdFuzzer::new(tuple_list!(stage));

fuzzer
    .fuzz_loop(&amp;mut state, &amp;mut executor, &amp;mut mgr, &amp;scheduler)
    .expect(&quot;Error in the fuzzing loop&quot;.into());
<span class="boring">}
</span></code></pre></pre>
<p><code>fuzz_loop</code> will request a testcase for each iteration to the fuzzer using the scheduler and then it will invoke the stage.</p>
<p>After adding this code, we have a proper fuzzer, that can run a find the input that panics the function in less than a second.</p>
<pre><code>$ cargo run
   Compiling baby_fuzzer v0.1.0 (/home/andrea/Desktop/baby_fuzzer)
    Finished dev [unoptimized + debuginfo] target(s) in 1.56s
     Running `target/debug/baby_fuzzer`
[New Testcase] clients: 1, corpus: 2, objectives: 0, executions: 1, exec/sec: 0
[LOG Debug]: Loaded 1 over 8 initial testcases
[New Testcase] clients: 1, corpus: 3, objectives: 0, executions: 804, exec/sec: 0
[New Testcase] clients: 1, corpus: 4, objectives: 0, executions: 1408, exec/sec: 0
thread 'main' panicked at '=)', src/main.rs:35:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Crashed with SIGABRT
Child crashed!
[Objective] clients: 1, corpus: 4, objectives: 1, executions: 1408, exec/sec: 0
Waiting for broker...
Bye!
</code></pre>
<p>As you can see, after the panic message, the <code>objectives</code> count of the log increased by one and you will find the crashing input in <code>crashes/id_0</code>.</p>
<h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>In this chapter, we introduce the abstract Core Concepts behind LibAFL, we then discuss how we designed the library to take into account these concepts while allowing code reuse and extensibility.</p>
<h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>LibAFL is designed around some core concepts that we think can effectively abstract most of the other fuzzers designs.</p>
<p>Here, we discuss these concepts and provide some examples related to other fuzzers.</p>
<p>TODO add links to trait definitions in docs.rs</p>
<h2 id="observer"><a class="header" href="#observer">Observer</a></h2>
<p>An Observer, or Observation Channel, is an entity that provides an information observed during the execution of the program under test to the fuzzer.</p>
<p>The information contained in the Observer is not preserved cross executions.</p>
<p>As an example, the coverage shared map filled during the execution to report the executed edges used by fuzzers such as AFL and HoggFuzz can be considered an Observation Channel.
This information is not preserved accros runs and it is an observation of a dynamic property of the program.</p>
<h2 id="executor"><a class="header" href="#executor">Executor</a></h2>
<p>In different fuzzers, the concept of executing the program under test each run is now always the same.
For instance, for in-memory fuzzers like libFuzzer an execution is a call to an harness function, for hypervisor-based fuzzers like <a href="https://github.com/IntelLabs/kAFL">kAFL</a> instead an entire operating system is started from a snapshot each run.</p>
<p>In our model, an Executor is the entity that defines not only how to execute the target, but all the volatile operations that are related to just a single run of the target.</p>
<p>So the Executor is for instance reponsible to inform the program about the input that the fuzzer wants to use in the run, writing to a memory location for instance or passing it as a parameter to the harness function.</p>
<p>It also holds a set of Observers, as thay are related to just a single run of the target.</p>
<h2 id="feedback"><a class="header" href="#feedback">Feedback</a></h2>
<p>The Feedback is an entity that classify the outcome of an execution of the program under test as interesting or not.
Tipically, if an exeuction is interesting, the corresponding input used to feed the target program is added to a corpus.</p>
<p>Most of the times, the notion of Feedback is deeply linked to the Observer, but they are different concepts.</p>
<p>The Feedback, in most of the cases, process the information reported by one or more observer to decide if the execution is interesting.
The concept of &quot;interestingness&quot; is abstract, but tipically it is related to a novelty search (i.e. interesting inputs are those that reach a previosly unseen edge in the control flow graph).</p>
<p>As an example, given an Observer that reports all the size of memory allocations, a maximization Feedback can be used to maximize these sizes to sport patological inputs in terms of memory consumption.</p>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>Formally, the input of a program is the data taken from external sources and that affect the program behaviour.</p>
<p>In our model of an abstarct fuzzer, we define the Input as the internal representation of the program input (or a part of it).</p>
<p>In the straightforward case, the input of the program is a byte array and in fuzzers such as AFL we store an manipulate exaclty these byte arrays.</p>
<p>But it is not always the case. A program can expect inputs that are not byte arrays (e.g. a sequence of syscalls) and the fuzzer does not represent the Input in the same way that the program consume it.</p>
<p>In case of a grammar fuzzer for instance, the Input is generally an Abstract Syntax Tree because it is a data structure that can be easily manipulated while maintaining the validity, but the program expects a byte array as input so, just before the execution, the tree is serialized to a sequence of bytes.</p>
<h2 id="corpus"><a class="header" href="#corpus">Corpus</a></h2>
<p>The Corpus is where testcases are stored. A Testcase is defined as an Input and a set of related metadata like execution time for instance.</p>
<p>For instance, a Corpus can store testcases on disk, or in memory, or implement a cache to speedup on disk storage.</p>
<p>Usually, a testcase is added to the Corpus when it is considered as interesting.</p>
<h2 id="mutator"><a class="header" href="#mutator">Mutator</a></h2>
<p>The Mutator is an entitiy that takes one or more Inputs and generates a new derived one.</p>
<p>Mutators can be composed and they are generally linked to a specific Input type.</p>
<p>There can be, for instance, a Mutator that applies more than a single type of mutation on the input. Consider a generic Mutator for a byte stream, bit flip is just one of the possible mutations but not the single one, there is also, for instance, the random replacement of a byte of the copy of a chunk.</p>
<p>This Mutator will simple schedule the application of some other Mutators.</p>
<h2 id="generator"><a class="header" href="#generator">Generator</a></h2>
<p>A Generator is a component designed to generate an Input from scratch.</p>
<p>Tipically, a random generator is used to generate random inputs.</p>
<p>Generators are traditionally less used in Feedback-driven Fuzzing, but there are exceptions, like Nautilus, that uses a Grammar generator to create the initial corpus and a sub-tree Generator as a mutation of its grammar Mutator.</p>
<h2 id="stage"><a class="header" href="#stage">Stage</a></h2>
<p>A Stage is an entity that operates on a single Input got from the Corpus.</p>
<p>For instance, a Mutational Stage, given an input of the corpus, applies a Mutator and executes the generated input one or more time. How many times this has to be done can be scheduled, AFL for instance use a performance score of the input to choose how many times the havoc mutator should be invoked. This can depends also on other parameters, for instance, the length of the input if we want to just apply a sequential bitflip, or be a fixed value.</p>
<p>A stage can be also an analysis stage, for instance, the Colorization stage of Redqueen that aims to introduce more entropy in a testcase or the Trimming stage of AFL that aims to reduce the size of a testcase.</p>
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The LibAFL architecture is built around some entities to allow code reuse and low-cost abstractions.</p>
<p>Initially, we started thinking to implement LibAFL in an Object Oriented language, such C++. When we landed to Rust, we immediately changed our idea as we realized that, while Rust allows a sort of OOP pattern, we can build the library using a more sane approach like the one described in <a href="https://kyren.github.io/2018/09/14/rustconf-talk.html">this blogpost</a> about game design in Rust.</p>
<p>The LibAFL code reuse meachanism is so based on components rather than sub-classes, but there are still some OOP patterns in the library.</p>
<p>Thinking about similar fuzzers, you can observe that most of the times the data structures that are modified are the ones related to testcases and the fuzzer global state.</p>
<p>Beside the entities described previously, we introduce the Testcase and State entities. The Testcase is a container for an Input stored in the Corpus and its metadata (so, in the implementation, the Corpus stores Testcases) and the State contains all the metadata that are evolved while running the fuzzer, Corpus included.</p>
<h1 id="understanding-metadata"><a class="header" href="#understanding-metadata">Understanding Metadata</a></h1>
<p>In this chapter, we discuss in depth the metadata system of LibAFL and its usage.</p>
<h1 id="definition"><a class="header" href="#definition">Definition</a></h1>
<p>A metadata in LibAFL is a self contained structure that holds associated data to the State or to a Testcase.</p>
<p>In terms of code, a metadata can be defined as a Rust struct registered in the SerdeAny register.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libafl::SerdeAny;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, SerdeAny)]
pub struct MyMetadata {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The struct must be static, so it cannot hold references to borrowed objects.</p>
<h1 id="deserialization"><a class="header" href="#deserialization">(De)Serialization</a></h1>
<p>TODO describe the SerdeAny registry</p>
<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>TODO describe the HasMetadata interface</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
