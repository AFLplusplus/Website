<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The LibAFL Fuzzing Library</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="libafl.html">The LibAFL Fuzzing Library</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting_started/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="getting_started/build.html"><strong aria-hidden="true">1.2.</strong> Build</a></li><li class="chapter-item expanded "><a href="getting_started/crates.html"><strong aria-hidden="true">1.3.</strong> Crates</a></li></ol></li><li class="chapter-item expanded "><a href="baby_fuzzer.html"><strong aria-hidden="true">2.</strong> Baby Fuzzer</a></li><li class="chapter-item expanded "><a href="design/design.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/core_concepts.html"><strong aria-hidden="true">3.1.</strong> Core Concepts</a></li><li class="chapter-item expanded "><a href="design/architecture.html"><strong aria-hidden="true">3.2.</strong> Architecture</a></li></ol></li><li class="chapter-item expanded "><a href="medatata/metadata.html"><strong aria-hidden="true">4.</strong> Understanding Metadata</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="medatata/definition.html"><strong aria-hidden="true">4.1.</strong> Definition</a></li><li class="chapter-item expanded "><a href="medatata/de_serialization.html"><strong aria-hidden="true">4.2.</strong> (De)Serialization</a></li><li class="chapter-item expanded "><a href="medatata/usage.html"><strong aria-hidden="true">4.3.</strong> Usage</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The LibAFL Fuzzing Library</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-libafl-fuzzing-library"><a class="header" href="#the-libafl-fuzzing-library">The LibAFL Fuzzing Library</a></h1>
<p><em>by Andrea Fioraldi and Dominik Maier</em></p>
<p>This version of the LibAFL book is coupled with the release 1.0 beta of the library.</p>
<p>This document is still work-in-progress and incomplete. The structure and the concepts explained here are subject to change in future revisions, as the structure of LibAFL itself will evolve.</p>
<p>The HTML version of this book is available online at PLACEHOLDER and offline from the LibAFL repository in the docs/ folder.</p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Fuzzers are important assets in the pockets of security researchers and developers alike.
A wide range of cool state-of-the-art tools like <a href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a>, <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a> or <a href="https://github.com/google/honggfuzz">honggfuzz</a> are available to users. They do their job in a very effective way, finding thousands of bugs.</p>
<p>From the power user perspective, however, these tools are limited.
Their design does not treat extensibility as a first-class citizen.
Usually, a fuzzer developer can choose to either fork one of these existing tools, or to create a new fuzzer from scratch.
In any case, researchers end up with tons of fuzzers, all of which are incompatible with each other.
Their outstanding features can not just be combined for new projects.
Instead, we keep reinventing the wheel and may completely miss out on features that are complex to reimplement.</p>
<p>Here comes LibAFL, a library that IS NOT a fuzzer, but a collection of reusable pieces of fuzzers, written in Rust.
LibAFL helps you develop your own custom fuzzer, tailored for your specific needs.
Be it a specific target, a particular instrumentation backend, or a custom mutator, you can leverage existing bits and pieces to craft the fastest and most efficient fuzzer you can envision.</p>
<h2 id="why-libafl"><a class="header" href="#why-libafl">Why LibAFL?</a></h2>
<p>LibAFL gives you many of the benefits of an off-the-shelf fuzzer, while being completely customizable.
Some highlight features currently include:</p>
<ul>
<li><code>multi platform</code>: LibAFL works pretty much anywhere you can find a Rust compiler for. We already used it on <em>Windows</em>, <em>Android</em>, <em>MacOS</em>, and <em>Linux</em>, on <em>x86_64</em>, <em>aarch64</em>, ...</li>
<li><code>portable</code>: <code>LibAFL</code> can be built in <code>no_std</code> mode. This means it does not require a specific OS-dependent runtime to function. Define an allocator and a way to map pages, you should be good to inject LibAFL in obscure targets like embedded devices, hypervisors, or maybe even WebAssembly?</li>
<li><code>adaptable</code>: Given year of experience fine-tuning <em>AFLplusplus</em> and our academic fuzzing background, we could incorporate recent fuzzing trends into LibAFL's deign and make it future-proof.
To give an example, as opposed to old-skool fuzzers, a <code>BytesInput</code> is just one of the potential forms of inputs:
feel free to use and mutate an Abstract Syntax Tree instead, for structured fuzzing.</li>
<li><code>scalable</code>: As part of LibAFL, we developed <code>Low Level Message Passing</code>, <code>LLMP</code> for short, which allows LibAFL to scale almost linearly over cores. That is, if you chose to use this feature - it is your fuzzer, after all. Scaling to multiple machines over TCP is on the near road-map.</li>
<li><code>fast</code>: We do everything we can at compiletime so that the runtime overhead is as minimal as it can get.</li>
<li><code>bring your own target</code>: We support binary-only modes, like Frida-Mode with ASAN and CmpLog, as well as multiple compilation passes for sourced-based instrumentation, and of course supoprt custom instrumentation.</li>
<li><code>usable</code>: This one is on you to decide. Dig right in!</li>
</ul>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To start using LibAFL, there are some first steps to do. In this chapter, we will
discuss how to download LibAFL and build with <code>cargo</code>, how are structured its crates and the purpose of each crate.</p>
<h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>The first step is to download LibAFL and all its dependencies that are not automatically installed with <code>cargo</code>.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>In this chapter and throughout the book, we’ll show some commands used in the
terminal. Lines that you should enter in a terminal all start with <code>$</code>. You
don’t need to type in the <code>$</code> character; it indicates the start of each
command. Lines that don’t start with <code>$</code> typically show the output of the
previous command. Additionally, PowerShell-specific examples will use <code>&gt;</code>
rather than <code>$</code>.</p>
</blockquote>
<p>The easiest way to download LibAFL is using <code>git</code>.</p>
<pre><code class="language-sh">$ git clone git@github.com:AFLplusplus/LibAFL.git
</code></pre>
<p>You can alternatively, on a UNIX-like machine, download a compressed archive and extract with:</p>
<pre><code class="language-sh">$ wget https://github.com/AFLplusplus/LibAFL/archive/main.tar.gz
$ tar xvf LibAFL-main.tar.gz
$ rm LibAFL-main.tar.gz
$ ls LibAFL-main # this is the extracted folder
</code></pre>
<h2 id="clang-installation"><a class="header" href="#clang-installation">Clang installation</a></h2>
<p>One of the external dependencies of LibAFL is the Clang C/C++ compiler.
While most of the code is in pure Rust, we still need a C compiler because Rust stable
still does not support features that we need such as weak linking and LLVM builtins linking,
and so we use C to expose the missing functionalities to our Rust codebase.</p>
<p>In addition, if you want to perform source-level fuzz testing of C/C++ applications,
you will likely need Clang with its instrumentation options to compile the programs
under test.</p>
<p>On Linux you can use your distro's package manager to get Clang,
but these packages are not always updated, so we suggest you to use the
Debian/Ubuntu prebuilt packages from LLVM that are available using their <a href="https://apt.llvm.org/">official repository</a>.</p>
<p>For Microsoft Windows, you can download the <a href="https://llvm.org/builds/">installer package</a> that LLVM generates periodically.</p>
<p>Despite that Clang is the default C compiler on macOS, we discourage the use of the build shipped by Apple and encourage
the installation from <code>brew</code> or directly a fresh build from the source code.</p>
<p>Alternatively you can download and build the LLVM source tree - Clang included - following the steps
explained <a href="https://clang.llvm.org/get_started.html">here</a>.</p>
<h2 id="rust-installation"><a class="header" href="#rust-installation">Rust installation</a></h2>
<p>If you don't have Rust installed, you can easily follow the steps described <a href="https://www.rust-lang.org/tools/install">here</a>
to install it on any supported system.</p>
<p>We suggest to install Clang and LLVM first.</p>
<h1 id="build"><a class="header" href="#build">Build</a></h1>
<p>LibAFL, as most of the Rust projects, can be built using <code>cargo</code> from the root directory of the project with:</p>
<pre><code class="language-sh">$ cargo build --release
</code></pre>
<p>Note that the <code>--release</code> flag is optional for development, but you needed to add it to fuzzing at a decent speed.
Slowdowns of 10x or more are not uncommon for Debug builds.</p>
<p>The LibAFL repository is composed of multiple crates.
The top-level Cargo.toml is the workspace file grouping these crates.
Calling <code>cargo build</code> from the root directory will compile all crates in the workspace.</p>
<h2 id="build-example-fuzzers"><a class="header" href="#build-example-fuzzers">Build Example Fuzzers</a></h2>
<p>We group example fuzzers in the <code>./fuzzers</code> directory of the LibAFL repository.
The directory contains a set of crates that are not part of the workspace.</p>
<p>Each of these example fuzzers uses particular features of LibAFL, sometimes combined with different instrumentation backends (e.g. <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>, <a href="https://frida.re/">Frida</a>, ...).</p>
<p>You can use these crates as examples and as skeletons for custom fuzzers with similar featuresets.</p>
<p>To build an example fuzzer you have to invoke cargo from its respective folder (`fuzzers/[FUZZER_NAME]).</p>
<h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>LibAFL is composed by different crates.
Each one has its self-contained purpose, and the user may not need to use all of them in its project.</p>
<p>Following the naming convention of the folders in the project's root, they are:</p>
<h3 id="libafl"><a class="header" href="#libafl">libafl</a></h3>
<p>This is the main crate that contains all the components needed to build a fuzzer.</p>
<p>This crate has the following feature flags:</p>
<ul>
<li>std, that enables the parts of the code that use the Rust standard library. Without this flags, libafl is no_std.</li>
<li>derive, that enables the usage of the <code>derive(...)</code> macros defined in libafl_derive from libafl.</li>
</ul>
<p>By default, std and derive are both set.</p>
<h3 id="libafl_derive"><a class="header" href="#libafl_derive">libafl_derive</a></h3>
<p>This a proc-macro crate paired with the libafl crate.</p>
<p>At the moment, it just expose the <code>derive(SerdeAny)</code> macro that can be used to define metadata structs.</p>
<h3 id="libafl_targets"><a class="header" href="#libafl_targets">libafl_targets</a></h3>
<p>This crate that exposes, under feature flags, pieces of code to interact with targets</p>
<p>Currently, the supported flags are:</p>
<ul>
<li>pcguard_edges, that defines the SanitizerCoverage trace-pc-guard hooks to track the executed edges in a map.</li>
<li>pcguard_hitcounts, that defines the SanitizerCoverage trace-pc-guard hooks to track the executed edges with the hitcounts (like AFL) in a map.</li>
<li>libfuzzer, that expose a compatibility layer with libFuzzer style harnesses.</li>
<li>value_profile, that defines the SanitizerCoverage trace-cmp hooks to track the matching bits of each comparison in a map. </li>
</ul>
<h3 id="libafl_cc"><a class="header" href="#libafl_cc">libafl_cc</a></h3>
<p>This is a library that provides some utils to wrap compilers and create source level fuzzers.</p>
<p>At the moment, only the Clang compiler is supported.</p>
<h1 id="baby-fuzzer"><a class="header" href="#baby-fuzzer">Baby Fuzzer</a></h1>
<h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>In this chapter, we introduce the abstract Core Concepts behind LibAFL, we then discuss how we designed the library to take into account these concepts while allowing code reuse and extensibility.</p>
<h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>LibAFL is designed around some core concepts that we think can effectively abstract most of the other fuzzers designs.</p>
<p>Here, we discuss these concepts and provide some examples related to other fuzzers.</p>
<p>TODO add links to trait definitions in docs.rs</p>
<h2 id="observer"><a class="header" href="#observer">Observer</a></h2>
<p>An Observer, or Observation Channel, is an entity that provides an information observed during the execution of the program under test to the fuzzer.</p>
<p>The information contained in the Observer is not preserved cross executions.</p>
<p>As an example, the coverage shared map filled during the execution to report the executed edges used by fuzzers such as AFL and HoggFuzz can be considered an Observation Channel.
This information is not preserved accros runs and it is an observation of a dynamic property of the program.</p>
<h2 id="executor"><a class="header" href="#executor">Executor</a></h2>
<p>In different fuzzers, the concept of executing the program under test each run is now always the same.
For instance, for in-memory fuzzers like libFuzzer an execution is a call to an harness function, for hypervisor-based fuzzers like <a href="https://github.com/IntelLabs/kAFL">kAFL</a> instead an entire operating system is started from a snapshot each run.</p>
<p>In our model, an Executor is the entity that defines not only how to execute the target, but all the volatile operations that are related to just a single run of the target.</p>
<p>So the Executor is for instance reponsible to inform the program about the input that the fuzzer wants to use in the run, writing to a memory location for instance or passing it as a parameter to the harness function.</p>
<p>It also holds a set of Observers, as thay are related to just a single run of the target.</p>
<h2 id="feedback"><a class="header" href="#feedback">Feedback</a></h2>
<p>The Feedback is an entity that classify the outcome of an execution of the program under test as interesting or not.
Tipically, if an exeuction is interesting, the corresponding input used to feed the target program is added to a corpus.</p>
<p>Most of the times, the notion of Feedback is deeply linked to the Observer, but they are different concepts.</p>
<p>The Feedback, in most of the cases, process the information reported by one or more observer to decide if the execution is interesting.
The concept of &quot;interestingness&quot; is abstract, but tipically it is related to a novelty search (i.e. interesting inputs are those that reach a previosly unseen edge in the control flow graph).</p>
<p>As an example, given an Observer that reports all the size of memory allocations, a maximization Feedback can be used to maximize these sizes to sport patological inputs in terms of memory consumption.</p>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>Formally, the input of a program is the data taken from external sources and that affect the program behaviour.</p>
<p>In our model of an abstarct fuzzer, we define the Input as the internal representation of the program input (or a part of it).</p>
<p>In the straightforward case, the input of the program is a byte array and in fuzzers such as AFL we store an manipulate exaclty these byte arrays.</p>
<p>But it is not always the case. A program can expect inputs that are not byte arrays (e.g. a sequence of syscalls) and the fuzzer does not represent the Input in the same way that the program consume it.</p>
<p>In case of a grammar fuzzer for instance, the Input is generally an Abstract Syntax Tree because it is a data structure that can be easily manipulated while maintaining the validity, but the program expects a byte array as input so, just before the execution, the tree is serialized to a sequence of bytes.</p>
<h2 id="corpus"><a class="header" href="#corpus">Corpus</a></h2>
<p>The Corpus is where testcases are stored. A Testcase is defined as an Input and a set of related metadata like execution time for instance.</p>
<p>For instance, a Corpus can store testcases on disk, or in memory, or implement a cache to speedup on disk storage.</p>
<p>Usually, a testcase is added to the Corpus when it is considered as interesting.</p>
<h2 id="mutator"><a class="header" href="#mutator">Mutator</a></h2>
<p>The Mutator is an entitiy that takes one or more Inputs and generates a new derived one.</p>
<p>Mutators can be composed and they are generally linked to a specific Input type.</p>
<p>There can be, for instance, a Mutator that applies more than a single type of mutation on the input. Consider a generic Mutator for a byte stream, bit flip is just one of the possible mutations but not the single one, there is also, for instance, the random replacement of a byte of the copy of a chunk.</p>
<p>This Mutator will simple schedule the application of some other Mutators.</p>
<h2 id="generator"><a class="header" href="#generator">Generator</a></h2>
<p>A Generator is a component designed to generate an Input from scratch.</p>
<p>Tipically, a random generator is used to generate random inputs.</p>
<p>Generators are traditionally less used in Feedback-driven Fuzzing, but there are exceptions, like Nautilus, that uses a Grammar generator to create the initial corpus and a sub-tree Generator as a mutation of its grammar Mutator.</p>
<h2 id="stage"><a class="header" href="#stage">Stage</a></h2>
<p>A Stage is an entity that operates on a single Input got from the Corpus.</p>
<p>For instamce, a Mutational Stage, given an input of the corpus, applies a Mutator and executes the generated input one or more time. How many times this has to be done can be scheduled, AFL for instance use a performance score of the input to choose how many times the havoc mutator should be invoked. This can depends also on other parameters, for instance, the length of the input if we want to just apply a sequential bitflip, or be a fixed value.</p>
<p>A stage can be also an analysis stage, for instance, the Colorization stage of Redqueen that aims to introduce more entropy in a testcase or the Trimming stage of AFL that aims to reduce the size of a testcase.</p>
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The LibAFL architecture is built around some entities to allow code reuse and low-cost abstractions.</p>
<p>Initially, we started thinking to implement LibAFL in an Object Oriented language, such C++. When we landed to Rust, we immediately changed our idea as we realized that, while Rust allows a sort of OOP pattern, we can build the library using a more sane approach like the one described in <a href="https://kyren.github.io/2018/09/14/rustconf-talk.html">this blogpost</a> about game design in Rust.</p>
<p>The LibAFL code reuse meachanism is so based on components rather than sub-classes, but there are still some OOP patterns in the library.</p>
<p>Thinking about similar fuzzers, you can observe that most of the times the data structures that are modified are the ones related to testcases and the fuzzer global state.</p>
<p>Beside the entities described previously, we introduce the Testcase and State entities. The Testcase is a container for an Input stored in the Corpus and its metadata (so, in the implementation, the Corpus stores Testcases) and the State contains all the metadata that are evolved while running the fuzzer, Corpus included.</p>
<h1 id="understanding-metadata"><a class="header" href="#understanding-metadata">Understanding Metadata</a></h1>
<p>In this chapter, we discuss in depth the metadata system of LibAFL and its usage.</p>
<h1 id="definition"><a class="header" href="#definition">Definition</a></h1>
<p>A metadata in LibAFL is a self contained structure that holds associated data to the State or to a Testcase.</p>
<p>In terms of code, a metadata can be defined as a Rust struct registered in the SerdeAny register.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libafl::SerdeAny;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, SerdeAny)]
pub struct MyMetadata {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The struct must be static, so it cannot hold references to borrowed objects.</p>
<h1 id="deserialization"><a class="header" href="#deserialization">(De)Serialization</a></h1>
<p>TODO describe the SerdeAny registry</p>
<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>TODO describe the HasMetadata interface</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
