<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The LibAFL Fuzzing Library</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="libafl.html">The LibAFL Fuzzing Library</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting_started/getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="getting_started/build.html"><strong aria-hidden="true">1.2.</strong> Build</a></li><li class="chapter-item expanded "><a href="getting_started/crates.html"><strong aria-hidden="true">1.3.</strong> Crates</a></li></ol></li><li class="chapter-item expanded "><a href="baby_fuzzer/baby_fuzzer.html"><strong aria-hidden="true">2.</strong> Baby Fuzzer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="baby_fuzzer/more_examples.html"><strong aria-hidden="true">2.1.</strong> More Examples</a></li></ol></li><li class="chapter-item expanded "><a href="core_concepts/core_concepts.html"><strong aria-hidden="true">3.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_concepts/observer.html"><strong aria-hidden="true">3.1.</strong> Observer</a></li><li class="chapter-item expanded "><a href="core_concepts/executor.html"><strong aria-hidden="true">3.2.</strong> Executor</a></li><li class="chapter-item expanded "><a href="core_concepts/feedback.html"><strong aria-hidden="true">3.3.</strong> Feedback</a></li><li class="chapter-item expanded "><a href="core_concepts/input.html"><strong aria-hidden="true">3.4.</strong> Input</a></li><li class="chapter-item expanded "><a href="core_concepts/corpus.html"><strong aria-hidden="true">3.5.</strong> Corpus</a></li><li class="chapter-item expanded "><a href="core_concepts/mutator.html"><strong aria-hidden="true">3.6.</strong> Mutator</a></li><li class="chapter-item expanded "><a href="core_concepts/generator.html"><strong aria-hidden="true">3.7.</strong> Generator</a></li><li class="chapter-item expanded "><a href="core_concepts/stage.html"><strong aria-hidden="true">3.8.</strong> Stage</a></li></ol></li><li class="chapter-item expanded "><a href="design/design.html"><strong aria-hidden="true">4.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/architecture.html"><strong aria-hidden="true">4.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="design/metadata.html"><strong aria-hidden="true">4.2.</strong> Metadata</a></li><li class="chapter-item expanded "><a href="design/migration-0.9.html"><strong aria-hidden="true">4.3.</strong> Migrating from LibAFL &lt;0.9 to 0.9</a></li><li class="chapter-item expanded "><a href="design/migration-0.11.html"><strong aria-hidden="true">4.4.</strong> Migrating from LibAFL &lt;0.11 to 0.11</a></li></ol></li><li class="chapter-item expanded "><a href="message_passing/message_passing.html"><strong aria-hidden="true">5.</strong> Message Passing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="message_passing/spawn_instances.html"><strong aria-hidden="true">5.1.</strong> Spawning Instances</a></li><li class="chapter-item expanded "><a href="message_passing/configurations.html"><strong aria-hidden="true">5.2.</strong> Configurations</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/tutorial.html"><strong aria-hidden="true">6.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/intro.html"><strong aria-hidden="true">6.1.</strong> Introduction</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_features/advanced_features.html"><strong aria-hidden="true">7.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced_features/frida.html"><strong aria-hidden="true">7.1.</strong> Binary-Only Fuzzing with Frida</a></li><li class="chapter-item expanded "><a href="advanced_features/concolic.html"><strong aria-hidden="true">7.2.</strong> Concolic Tracing &amp; Hybrid Fuzzing</a></li><li class="chapter-item expanded "><a href="advanced_features/no_std.html"><strong aria-hidden="true">7.3.</strong> LibAFL in no_std environments (Kernels, Hypervisors, ...)</a></li><li class="chapter-item expanded "><a href="advanced_features/nyx.html"><strong aria-hidden="true">7.4.</strong> Snapshot Fuzzing in Nyx</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The LibAFL Fuzzing Library</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-libafl-fuzzing-library"><a class="header" href="#the-libafl-fuzzing-library">The LibAFL Fuzzing Library</a></h1>
<img align="right" src="https://raw.githubusercontent.com/AFLplusplus/Website/main/static/libafl_logo.svg" alt="LibAFL Logo" style="width: 256px; height: auto">
<p><em>by Andrea Fioraldi and Dominik Maier</em></p>
<p>Welcome to LibAFL, the Advanced Fuzzing Library.
This book shall be a gentle introduction to the library.</p>
<p>This version of the LibAFL book is coupled with the release 1.0 beta of the library.</p>
<p>This document is still work-in-progress and incomplete. The structure and the concepts explained here are subject to change in future revisions, as the structure of LibAFL itself will evolve.</p>
<p>The HTML version of this book is available online at <a href="https://aflplus.plus/libafl-book/">https://aflplus.plus/libafl-book/</a> and offline from the LibAFL repository in the <code>docs/</code> folder.
Build it using <code>mdbook build</code> in this folder, or run <code>mdbook serve</code> to view the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Fuzzers are important tools for security researchers and developers alike.
A wide range of state-of-the-art tools like <a href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a>, <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a> or <a href="https://github.com/google/honggfuzz">honggfuzz</a> are available to users. They do their job in a very effective way, finding thousands of bugs.</p>
<p>From the perspective of a power user, however, these tools are limited.
Their designs do not treat extensibility as a first-class citizen.
Usually, a fuzzer developer can choose to either fork one of these existing tools, or to create a new fuzzer from scratch.
In any case, researchers end up with tons of fuzzers, all of which are incompatible with each other.
Their outstanding features cannot just be combined for new projects.
By reinventing the wheel over and over, we may completely miss out on features that are complex to reimplement.</p>
<p>To tackle this issue, we created LibAFL, a library that is <em>not just another fuzzer</em>, but a collection of reusable pieces for individual fuzzers.
LibAFL, written in Rust, helps you develop a fuzzer tailored for your specific needs.
Be it a specific target, a particular instrumentation backend, or a custom mutator, you can leverage existing bits and pieces to craft the fastest and most efficient fuzzer you can envision.</p>
<h2 id="why-libafl"><a class="header" href="#why-libafl">Why LibAFL?</a></h2>
<p>LibAFL gives you many of the benefits of an off-the-shelf fuzzer, while being completely customizable.
Some highlight features currently include:</p>
<ul>
<li><code>multi platform</code>: LibAFL works pretty much anywhere you can find a Rust compiler for. We already used it on <em>Windows</em>, <em>Android</em>, <em>MacOS</em>, and <em>Linux</em>, on <em>x86_64</em>, <em>aarch64</em>, ...</li>
<li><code>portable</code>: <code>LibAFL</code> can be built in <code>no_std</code> mode.
This means it does not require a specific OS-dependent runtime to function.
Define an allocator and a way to map pages, and you are good to inject LibAFL in obscure targets like embedded devices, hypervisors, or maybe even WebAssembly?</li>
<li><code>adaptable</code>: Given years of experience fine-tuning <em>AFLplusplus</em> and our academic fuzzing background, we could incorporate recent fuzzing trends into LibAFL's design and make it future-proof.
To give an example, as opposed to old-school fuzzers, a <code>BytesInput</code> is just one of the potential forms of inputs:
feel free to use and mutate an Abstract Syntax Tree instead, for structured fuzzing.</li>
<li><code>scalable</code>: As part of LibAFL, we developed <code>Low Level Message Passing</code>, <code>LLMP</code> for short, which allows LibAFL to scale almost linearly over cores. That is, if you chose to use this feature - it is your fuzzer, after all.
Scaling to multiple machines over TCP is also possible, using LLMP's <code>broker2broker</code> feature.</li>
<li><code>fast</code>: We do everything we can at compile time so that the runtime overhead is as minimal as it can get.</li>
<li><code>bring your own target</code>: We support binary-only modes, like (full-system) QEMU-Mode and Frida-Mode with ASan and CmpLog, as well as multiple compilation passes for sourced-based instrumentation.
Of course, we also support custom instrumentation, as you can see in the Python example based on Google's Atheris.</li>
<li><code>usable</code>: This one is on you to decide. Dig right in!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To get started with LibAFL, there are some initial steps to take.
In this chapter, we discuss how to download and build LibAFL, using Rust's <code>cargo</code> command.
We also describe the structure of LibAFL's components, so-called crates, and the purpose of each individual crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>The first step is to download LibAFL and all dependencies that are not automatically installed with <code>cargo</code>.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>In this chapter and throughout the book, we show some commands used in the
terminal. Lines that you should enter in a terminal all start with <code>$</code>. You
don’t need to type in the <code>$</code> character; it indicates the start of each
command. Lines that don’t start with <code>$</code> typically show the output of the
previous command. Additionally, PowerShell-specific examples will use <code>&gt;</code>
rather than <code>$</code>.</p>
</blockquote>
<p>While technically you do not need to install LibAFL, but can use the version from crates.io directly, we do recommend to download or clone the GitHub version.
This gets you the example fuzzers, additional utilities, and latest patches.
The easiest way to do this is to use <code>git</code>.</p>
<pre><code class="language-sh">$ git clone https://github.com/AFLplusplus/LibAFL.git
</code></pre>
<p>Alternatively, on a UNIX-like machine, you can download a compressed archive and extract it with:</p>
<pre><code class="language-sh">wget https://github.com/AFLplusplus/LibAFL/archive/main.tar.gz
$ tar xvf LibAFL-main.tar.gz
$ rm LibAFL-main.tar.gz
$ ls LibAFL-main # this is the extracted folder
</code></pre>
<h2 id="clang-installation"><a class="header" href="#clang-installation">Clang installation</a></h2>
<p>One of the external dependencies of LibAFL is the Clang C/C++ compiler.
While most of the code is written in pure Rust, we still need a C compiler because stable Rust still does not support features that some parts of LibAFL may need, such as weak linking, and LLVM builtins linking.
For these parts, we use C to expose the missing functionalities to our Rust codebase.</p>
<p>In addition, if you want to perform source-level fuzz testing of C/C++ applications,
you will likely need Clang with its instrumentation options to compile the programs
under test.</p>
<p>On Linux you could use your distribution's package manager to get Clang,
but these packages are not always up-to-date.
Instead, we suggest using the Debian/Ubuntu prebuilt packages from LLVM that are available using their <a href="https://apt.llvm.org/">official repository</a>.</p>
<p>For Microsoft Windows, you can download the <a href="https://llvm.org/builds/">installer package</a> that LLVM generates periodically.</p>
<p>Despite Clang being the default C compiler on MacOS, we discourage the use of the build shipped by Apple and encourage
the installation from <a href="https://brew.sh/">Homebrew</a>, using <code>brew install llvm</code>.</p>
<p>Alternatively, you can download and build the LLVM source tree - Clang included - following the steps
explained <a href="https://clang.llvm.org/get_started.html">here</a>.</p>
<h2 id="rust-installation"><a class="header" href="#rust-installation">Rust installation</a></h2>
<p>If you do not have Rust installed, you can easily follow the steps described <a href="https://www.rust-lang.org/tools/install">here</a>
to install it on any supported system.
Be aware that Rust versions shipped with Linux distributions may be outdated, LibAFL always targets the latest <code>stable</code> version available via <code>rustup upgrade</code>.</p>
<p>We suggest installing Clang and LLVM first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-libafl"><a class="header" href="#building-libafl">Building LibAFL</a></h1>
<p>LibAFL, as most of the Rust projects, can be built using <code>cargo</code> from the root directory of the project with:</p>
<pre><code class="language-sh">$ cargo build --release
</code></pre>
<p>Note that the <code>--release</code> flag is optional for development, but you need to add it to do fuzzing at a decent speed.
Slowdowns of 10x or more are not uncommon for Debug builds.</p>
<p>The LibAFL repository is composed of multiple crates.
The <a href="https://github.com/AFLplusplus/LibAFL/blob/main/Cargo.toml">top-level <code>Cargo.toml</code></a> is the workspace file grouping these crates.
Calling <code>cargo build</code> from the root directory will compile all crates in the workspace.</p>
<h2 id="build-example-fuzzers"><a class="header" href="#build-example-fuzzers">Build Example Fuzzers</a></h2>
<p>The best starting point for experienced rustaceans is to read through, and adapt, the example fuzzers.</p>
<p>We group these fuzzers in the <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers"><code>./fuzzers</code></a> directory of the LibAFL repository.
The directory contains a set of crates that are not part of the workspace.</p>
<p>Each of these example fuzzers uses particular features of LibAFL, sometimes combined with different instrumentation backends (e.g. <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>, <a href="https://frida.re/">Frida</a>, ...).</p>
<p>You can use these crates as examples and as skeletons for custom fuzzers with similar feature sets.
Each fuzzer will have a <code>README.md</code> file in its directory, describing the fuzzer and its features.</p>
<p>To build an example fuzzer, you have to invoke <code>cargo build --release</code> from its respective folder (<code>fuzzers/[FUZZER_NAME]</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>LibAFL is composed of different crates.
A crate is an individual library in Rust's Cargo build system, that you can use by adding it to your project's <code>Cargo.toml</code>, like:</p>
<pre><code class="language-toml">[dependencies]
libafl = { version = &quot;*&quot; }
</code></pre>
<h2 id="crate-list"><a class="header" href="#crate-list">Crate List</a></h2>
<p>For LibAFL, each crate has its self-contained purpose, and the user may not need to use all of them in their project.
Following the naming convention of the folders in the project's root, they are:</p>
<h3 id="a-hrefhttpsgithubcomaflpluspluslibafltreemainlibafllibafla"><a class="header" href="#a-hrefhttpsgithubcomaflpluspluslibafltreemainlibafllibafla"><a href="https://github.com/AFLplusplus/LibAFL/tree/main/libafl"><code>libafl</code></a></a></h3>
<p>This is the main crate that contains all the components needed to build a fuzzer.</p>
<p>This crate has a number of feature flags that enable and disable certain aspects of LibAFL.
The features can be found in <a href="https://github.com/AFLplusplus/LibAFL/blob/main/libafl/Cargo.toml">LibAFL's <code>Cargo.toml</code></a> under &quot;<code>[features]</code>&quot;, and are usually explained with comments there.
Some features worthy of remark are:</p>
<ul>
<li><code>std</code> enables the parts of the code that use the Rust standard library. Without this flag, LibAFL is <code>no_std</code> compatible. This disables a range of features, but allows us to use LibAFL in embedded environments, read <a href="getting_started/../advanced_features/no_std.html">the <code>no_std</code> section</a> for further details.</li>
<li><code>derive</code> enables the usage of the <code>derive(...)</code> macros defined in libafl_derive from libafl.</li>
<li><code>rand_trait</code> allows you to use LibAFL's very fast (<em>but insecure!</em>) random number generator wherever compatibility with Rust's <a href="https://crates.io/crates/rand"><code>rand</code> crate</a> is needed.</li>
<li><code>llmp_bind_public</code> makes LibAFL's LLMP bind to a public TCP port, over which other fuzzers nodes can communicate with this instance.</li>
<li><code>introspection</code> adds performance statistics to LibAFL.</li>
</ul>
<p>You can choose the features by using <code>features = [&quot;feature1&quot;, &quot;feature2&quot;, ...]</code> for LibAFL in your <code>Cargo.toml</code>.
Out of this list, by default, <code>std</code>, <code>derive</code>, and <code>rand_trait</code> are already set.
You can choose to disable them by setting <code>default-features = false</code> in your <code>Cargo.toml</code>.</p>
<h2 id="a-hrefhttpsgithubcomaflpluspluslibafltreemainlibafllibafl_boltsa"><a class="header" href="#a-hrefhttpsgithubcomaflpluspluslibafltreemainlibafllibafl_boltsa"><a href="https://github.com/AFLplusplus/LibAFL/tree/main/libafl">`libafl_bolts</a></a></h2>
<p>The <code>libafl_bolts</code> create is a minimal tool shed filled with useful low-level rust features, not necessarily related to fuzzers.
In it, you'll find highlights like:</p>
<ul>
<li><code>core_affinity</code> to bind the current process to cores</li>
<li><code>SerdeAnyMap</code> a map that can store typed values in a serializable fashion</li>
<li><code>minibsod</code> to dump the current process state</li>
<li><code>LLMP</code>, &quot;low level message passing&quot;, a lock-free IPC mechanism</li>
<li><code>Rand</code>, different fast (non-cryptographically secure) RNG implementations like RomuRand</li>
<li><code>ShMem</code>, a platform independent shard memory implementation</li>
<li><code>Tuples</code>, a compiletime tuple implementation</li>
</ul>
<p>... and much more.</p>
<h3 id="libafl_sugar"><a class="header" href="#libafl_sugar">libafl_sugar</a></h3>
<p>The sugar crate abstracts away most of the complexity of LibAFL's API.
Instead of high flexibility, it aims to be high-level and easy-to-use.
It is not as flexible as stitching your fuzzer together from each individual component, but allows you to build a fuzzer with minimal lines of code.
To see it in action, take a look at the <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/libfuzzer_stb_image_sugar"><code>libfuzzer_stb_image_sugar</code> example fuzzer</a>.</p>
<h3 id="libafl_derive"><a class="header" href="#libafl_derive">libafl_derive</a></h3>
<p>This a proc-macro crate paired with the <code>libafl</code> crate.</p>
<p>At the moment, it just exposes the <code>derive(SerdeAny)</code> macro that can be used to define Metadata structs, see the section about <a href="getting_started/../design/metadata.html">Metadata</a> for details.</p>
<h3 id="libafl_targets"><a class="header" href="#libafl_targets">libafl_targets</a></h3>
<p>This crate exposes code to interact with, and to instrument, targets.
To enable and disable features at compile-time, the features are enabled and disabled using feature flags.</p>
<p>Currently, the supported flags are:</p>
<ul>
<li><code>pcguard_edges</code> defines the SanitizerCoverage trace-pc-guard hooks to track the executed edges in a map.</li>
<li><code>pcguard_hitcounts</code> defines the SanitizerCoverage trace-pc-guard hooks to track the executed edges with the hitcounts (like AFL) in a map.</li>
<li><code>libfuzzer</code> exposes a compatibility layer with libFuzzer style harnesses.</li>
<li><code>value_profile</code> defines the SanitizerCoverage trace-cmp hooks to track the matching bits of each comparison in a map.</li>
</ul>
<h3 id="libafl_cc"><a class="header" href="#libafl_cc">libafl_cc</a></h3>
<p>This is a library that provides utils to wrap compilers and create source-level fuzzers.</p>
<p>At the moment, only the Clang compiler is supported.
To understand it deeper, look through the tutorials and examples.</p>
<h3 id="libafl_frida"><a class="header" href="#libafl_frida">libafl_frida</a></h3>
<p>This library bridges LibAFL with Frida as instrumentation backend.
With this crate, you can instrument targets on Linux/macOS/Windows/Android for coverage collection.
Additionally, it supports CmpLog, and AddressSanitizer instrumentation and runtimes for aarch64.
See further information, as well as usage instructions, <a href="getting_started/../advanced_features/frida.html">later in the book</a>.</p>
<h3 id="libafl_qemu"><a class="header" href="#libafl_qemu">libafl_qemu</a></h3>
<p>This library bridges LibAFL with QEMU user-mode to fuzz ELF cross-platform binaries.</p>
<p>It works on Linux and can collect edge coverage without collisions!
It also supports a wide range of hooks and instrumentation options.</p>
<h3 id="libafl_nyx"><a class="header" href="#libafl_nyx">libafl_nyx</a></h3>
<p><a href="https://nyx-fuzz.com/">Nyx</a> is a KVM-based snapshot fuzzer. <code>libafl_nyx</code> adds these capabilities to LibAFL. There is a specific section explaining usage of libafl_nyx <a href="getting_started/../advanced_features/nyx.html">later in the book</a>.</p>
<h3 id="libafl_concolic"><a class="header" href="#libafl_concolic">libafl_concolic</a></h3>
<p>Concolic fuzzing is the combination of fuzzing and a symbolic execution engine.
This can reach greater depth than normal fuzzing, and is exposed in this crate.
There is a specific section explaining usage of libafl_concolic <a href="getting_started/../advanced_features/concolic.html">later in the book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-libafl-fuzzer"><a class="header" href="#a-simple-libafl-fuzzer">A Simple LibAFL Fuzzer</a></h1>
<p>This chapter discusses a naive fuzzer using the LibAFL API.
You will learn about basic entities such as <code>State</code>, <code>Observer</code>, and <code>Executor</code>.
While the following chapters discuss the components of LibAFL in detail, here we introduce the fundamentals.</p>
<p>We are going to fuzz a simple Rust function that panics under a condition. The fuzzer will be single-threaded and will stop after the crash, just like libFuzzer normally does.</p>
<p>You can find a complete version of this tutorial as an example fuzzer in <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/baby_fuzzer"><code>fuzzers/baby_fuzzer</code></a>.</p>
<blockquote>
<h3 id="warning"><a class="header" href="#warning">Warning</a></h3>
<p>This example fuzzer is too naive for any real-world usage.
Its purpose is solely to show the main components of the library, for a more in-depth walkthrough on building a custom fuzzer go to the <a href="baby_fuzzer/../tutorial/intro.html">Tutorial chapter</a> directly.</p>
</blockquote>
<h2 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h2>
<p>We use cargo to create a new Rust project with LibAFL as a dependency.</p>
<pre><code class="language-console">$ cargo new baby_fuzzer
$ cd baby_fuzzer
</code></pre>
<p>The generated <code>Cargo.toml</code> looks like the following:</p>
<pre><code class="language-toml">[package]
name = &quot;baby_fuzzer_listing_01&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>In order to use LibAFl we must add it as dependency adding <code>libafl = { path = &quot;path/to/libafl/&quot; }</code> under <code>[dependencies]</code>.
That path actually needs to point to the <code>libafl</code> directory within the cloned repo, not the root of the repo itself.
You can use the LibAFL version from <a href="https://crates.io/crates/libafl">crates.io</a> if you want, in this case, you have to use <code>libafl = &quot;*&quot;</code> to get the latest version (or set it to the current version).</p>
<p>As we are going to fuzz Rust code, we want that a panic does not simply cause the program to exit, but raise an <code>abort</code> that can then be caught by the fuzzer.
To do that, we specify <code>panic = &quot;abort&quot;</code> in the <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">profiles</a>.</p>
<p>Alongside this setting, we add some optimization flags for the compilation, when building in release mode.</p>
<p>The final <code>Cargo.toml</code> should look similar to the following:</p>
<pre><code class="language-toml">[package]
name = &quot;baby_fuzzer_listing_02&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
libafl = { path = &quot;path/to/libafl/&quot; }
libafl_bolts = { path = &quot;path/to/libafl_bolts/&quot; }

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
lto = true
codegen-units = 1
opt-level = 3
debug = true
</code></pre>
<h2 id="the-function-under-test"><a class="header" href="#the-function-under-test">The function under test</a></h2>
<p>Opening <code>src/main.rs</code>, we have an empty <code>main</code> function.
To start, we create the closure that we want to fuzz. It takes a buffer as input and panics if it starts with <code>&quot;abc&quot;</code>.
<code>ExitKind</code> is used to inform the fuzzer about the harness' exit status.</p>
<pre><pre class="playground"><code class="language-rust">extern crate libafl;
extern crate libafl_bolts;
use libafl::{
    executors::ExitKind,
    inputs::{BytesInput, HasTargetBytes},
};
use libafl_bolts::AsSlice;

fn main() {
    let mut harness = |input: &amp;BytesInput| {
        let target = input.target_bytes();
        let buf = target.as_slice();
        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
                    panic!(&quot;=)&quot;);
                }
            }
        }
        ExitKind::Ok
    };
    // To test the panic:
    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
    #[cfg(feature = &quot;panic&quot;)]
    harness(&amp;input);
}
</code></pre></pre>
<p>To test the crash manually, you can add a feature in <code>Cargo.toml</code> that enables the call that triggers the panic:</p>
<pre><code class="language-toml">
[features]
</code></pre>
<p>And then run the program with that feature activated:</p>
<pre><code class="language-console">$ cargo run -F panic
</code></pre>
<p>And you should see the program crash as expected.</p>
<h2 id="generating-and-running-some-tests"><a class="header" href="#generating-and-running-some-tests">Generating and running some tests</a></h2>
<p>One of the main components that a LibAFL-based fuzzer uses is the State, a container of the data that will evolve during the fuzzing process.
It includes all state, such as the Corpus of inputs, the current RNG state, and potential Metadata for the testcases and run.
In our <code>main</code> we create a basic State instance like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span>    // create a State from scratch
    let mut state = StdState::new(
        // RNG
        StdRand::with_seed(current_nanos()),
        // Corpus that will be evolved, we keep it in memory for performance
        InMemoryCorpus::new(),
        // Corpus in which we store solutions (crashes in this example),
        // on disk so the user can get them after stopping the fuzzer
        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
        &amp;mut (),
        &amp;mut (),
    )
    .unwrap();
<span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, (), ());
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function
</span><span class="boring">    let mut executor = InProcessExecutor::new(&amp;mut harness, (), &amp;mut fuzzer, &amp;mut state, &amp;mut mgr)
</span><span class="boring">        .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p>The first parameter is a random number generator, that is part of the fuzzer state, in this case, we use the default one <code>StdRand</code>, but you can choose a different one. We seed it with the current nanoseconds.</p>
</li>
<li>
<p>The second parameter is an instance of something implementing the Corpus trait, <code>InMemoryCorpus</code> in this case. The corpus is the container of the testcases evolved by the fuzzer, in this case, we keep it all in memory.</p>
<p>To avoid type annotation error, you can use <code>InMemoryCorpus::&lt;BytesInput&gt;::new()</code> to replace <code>InMemoryCorpus::new()</code>. If not, type annotation will be automatically inferred when adding <code>executor</code>.</p>
</li>
<li>
<p>The third parameter is another Corpus that stores the &quot;solution&quot; testcases for the fuzzer. For our purpose, the solution is the input that triggers the panic. In this case, we want to store it to disk under the <code>crashes</code> directory, so we can inspect it.</p>
</li>
<li>
<p>The last two parameters are feedback and objective, we will discuss them later.</p>
</li>
</ul>
<p>Another required component is the <strong>EventManager</strong>. It handles some events such as the addition of a testcase to the corpus during the fuzzing process. For our purpose, we use the simplest one that just displays the information about these events to the user using a <code>Monitor</code> instance.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span>    // The Monitor trait defines how the fuzzer stats are displayed to the user
    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));

    // The event manager handles the various events generated during the fuzzing loop
    // such as the notification of the addition of a new item to the corpus
    let mut mgr = SimpleEventManager::new(mon);
<span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, (), ());
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function
</span><span class="boring">    let mut executor = InProcessExecutor::new(&amp;mut harness, (), &amp;mut fuzzer, &amp;mut state, &amp;mut mgr)
</span><span class="boring">        .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>In addition, we have the <strong>Fuzzer</strong>, an entity that contains some actions that alter the State. One of these actions is the scheduling of the testcases to the fuzzer using a <strong>Scheduler</strong>.
We create it as <code>QueueScheduler</code>, a scheduler that serves testcases to the fuzzer in a FIFO fashion.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span>    // A queue policy to get testcasess from the corpus
    let scheduler = QueueScheduler::new();

    // A fuzzer with feedbacks and a corpus scheduler
    let mut fuzzer = StdFuzzer::new(scheduler, (), ());
<span class="boring">
</span><span class="boring">    // Create the executor for an in-process function
</span><span class="boring">    let mut executor = InProcessExecutor::new(&amp;mut harness, (), &amp;mut fuzzer, &amp;mut state, &amp;mut mgr)
</span><span class="boring">        .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Last but not least, we need an <strong>Executor</strong> that is the entity responsible to run our program under test. In this example, we want to run the harness function in-process (without forking off a child, for example), and so we use the <code>InProcessExecutor</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, (), ());
</span><span class="boring">
</span>    // Create the executor for an in-process function
    let mut executor = InProcessExecutor::new(&amp;mut harness, (), &amp;mut fuzzer, &amp;mut state, &amp;mut mgr)
        .expect(&quot;Failed to create the Executor&quot;);
<span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>It takes a reference to the harness, the state, and the event manager. We will discuss the second parameter later.
As the executor expects that the harness returns an ExitKind object, so we have added <code>ExitKind::Ok</code> to our harness function before.</p>
<p>Now we have the 4 major entities ready for running our tests, but we still cannot generate testcases.</p>
<p>For this purpose, we use a <strong>Generator</strong>, <code>RandPrintablesGenerator</code> that generates a string of printable bytes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, (), ());
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function
</span><span class="boring">    let mut executor = InProcessExecutor::new(&amp;mut harness, (), &amp;mut fuzzer, &amp;mut state, &amp;mut mgr)
</span><span class="boring">        .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span>    // Generator of printable bytearrays of max size 32
    let mut generator = RandPrintablesGenerator::new(32);

    // Generate 8 initial inputs
    state
        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
        .expect(&quot;Failed to generate the initial corpus&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Now you can prepend the necessary <code>use</code> directives to your main.rs and compile the fuzzer.</p>
<pre><pre class="playground"><code class="language-rust">extern crate libafl;
extern crate libafl_bolts;

use libafl::{
    corpus::{InMemoryCorpus, OnDiskCorpus},
    events::SimpleEventManager,
    executors::{inprocess::InProcessExecutor, ExitKind},
    fuzzer::StdFuzzer,
    generators::RandPrintablesGenerator,
    inputs::{BytesInput, HasTargetBytes},
    monitors::SimpleMonitor,
    schedulers::QueueScheduler,
    state::StdState,
};
use libafl_bolts::{current_nanos, rands::StdRand, AsSlice};
use std::path::PathBuf;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">        &amp;mut (),
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, (), ());
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function
</span><span class="boring">    let mut executor = InProcessExecutor::new(&amp;mut harness, (), &amp;mut fuzzer, &amp;mut state, &amp;mut mgr)
</span><span class="boring">        .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>When running, you should see something similar to:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/baby_fuzzer`
[LOG Debug]: Loaded 0 over 8 initial testcases
</code></pre>
<h2 id="evolving-the-corpus-with-feedbacks"><a class="header" href="#evolving-the-corpus-with-feedbacks">Evolving the corpus with feedbacks</a></h2>
<p>Now you simply ran 8 randomly generated testcases, but none of them has been stored in the corpus. If you are very lucky, maybe you triggered the panic by chance but you don't see any saved file in <code>crashes</code>.</p>
<p>Now we want to turn our simple fuzzer into a feedback-based one and increase the chance to generate the right input to trigger the panic. We are going to implement a simple feedback based on the 3 conditions that are needed to reach the panic. To do that, we need a way to keep track of if a condition is satisfied.</p>
<p><strong>Observer</strong> can record the information about properties of a fuzzing run and then feeds the fuzzer. We use the <code>StdMapObserver</code>, the default observer that uses a map to keep track of covered elements. In our fuzzer, each condition is mapped to an entry of such map.</p>
<p>We represent such map as a <code>static mut</code> variable.
As we don't rely on any instrumentation engine, we have to manually track the satisfied conditions by <code>signals_set</code> in our harness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    feedbacks::{CrashFeedback, MaxMapFeedback},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    observers::StdMapObserver,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span>// Coverage map with explicit assignments due to the lack of instrumentation
static mut SIGNALS: [u8; 16] = [0; 16];

fn signals_set(idx: usize) {
    unsafe { SIGNALS[idx] = 1 };
}

fn main() {
    // The closure that we want to fuzz
    let mut harness = |input: &amp;BytesInput| {
        let target = input.target_bytes();
        let buf = target.as_slice();
        signals_set(0); // set SIGNALS[0]
        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
            signals_set(1); // set SIGNALS[1]
            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
                signals_set(2); // set SIGNALS[2]
                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
                    panic!(&quot;=)&quot;);
                }
            }
        }
        ExitKind::Ok
    };
<span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // Create an observation channel using the signals map
</span><span class="boring">    let observer = unsafe { StdMapObserver::new(&quot;signals&quot;, &amp;mut SIGNALS) };
</span><span class="boring">
</span><span class="boring">    // Feedback to rate the interestingness of an input
</span><span class="boring">    let mut feedback = MaxMapFeedback::new(&amp;observer);
</span><span class="boring">
</span><span class="boring">    // A feedback to choose if an input is a solution or not
</span><span class="boring">    let mut objective = CrashFeedback::new();
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut feedback,
</span><span class="boring">        &amp;mut objective,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function with just one observer
</span><span class="boring">    let mut executor = InProcessExecutor::new(
</span><span class="boring">        &amp;mut harness,
</span><span class="boring">        tuple_list!(observer),
</span><span class="boring">        &amp;mut fuzzer,
</span><span class="boring">        &amp;mut state,
</span><span class="boring">        &amp;mut mgr,
</span><span class="boring">    )
</span><span class="boring">    .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span>}
</code></pre></pre>
<p>The observer can be created directly from the <code>SIGNALS</code> map, in the following way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    feedbacks::{CrashFeedback, MaxMapFeedback},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    observers::StdMapObserver,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">// Coverage map with explicit assignments due to the lack of instrumentation
</span><span class="boring">static mut SIGNALS: [u8; 16] = [0; 16];
</span><span class="boring">
</span><span class="boring">fn signals_set(idx: usize) {
</span><span class="boring">    unsafe { SIGNALS[idx] = 1 };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // The closure that we want to fuzz
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        signals_set(0); // set SIGNALS[0]
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            signals_set(1); // set SIGNALS[1]
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                signals_set(2); // set SIGNALS[2]
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span>    // Create an observation channel using the signals map
    let observer = unsafe { StdMapObserver::new(&quot;signals&quot;, &amp;mut SIGNALS) };
<span class="boring">
</span><span class="boring">    // Feedback to rate the interestingness of an input
</span><span class="boring">    let mut feedback = MaxMapFeedback::new(&amp;observer);
</span><span class="boring">
</span><span class="boring">    // A feedback to choose if an input is a solution or not
</span><span class="boring">    let mut objective = CrashFeedback::new();
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut feedback,
</span><span class="boring">        &amp;mut objective,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function with just one observer
</span><span class="boring">    let mut executor = InProcessExecutor::new(
</span><span class="boring">        &amp;mut harness,
</span><span class="boring">        tuple_list!(observer),
</span><span class="boring">        &amp;mut fuzzer,
</span><span class="boring">        &amp;mut state,
</span><span class="boring">        &amp;mut mgr,
</span><span class="boring">    )
</span><span class="boring">    .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>The observers are usually kept in the corresponding executor as they keep track of information that is valid for just one run. We have then to modify our InProcessExecutor creation to include the observer as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    feedbacks::{CrashFeedback, MaxMapFeedback},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    observers::StdMapObserver,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">// Coverage map with explicit assignments due to the lack of instrumentation
</span><span class="boring">static mut SIGNALS: [u8; 16] = [0; 16];
</span><span class="boring">
</span><span class="boring">fn signals_set(idx: usize) {
</span><span class="boring">    unsafe { SIGNALS[idx] = 1 };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // The closure that we want to fuzz
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        signals_set(0); // set SIGNALS[0]
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            signals_set(1); // set SIGNALS[1]
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                signals_set(2); // set SIGNALS[2]
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // Create an observation channel using the signals map
</span><span class="boring">    let observer = unsafe { StdMapObserver::new(&quot;signals&quot;, &amp;mut SIGNALS) };
</span><span class="boring">
</span><span class="boring">    // Feedback to rate the interestingness of an input
</span><span class="boring">    let mut feedback = MaxMapFeedback::new(&amp;observer);
</span><span class="boring">
</span><span class="boring">    // A feedback to choose if an input is a solution or not
</span><span class="boring">    let mut objective = CrashFeedback::new();
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut feedback,
</span><span class="boring">        &amp;mut objective,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
</span><span class="boring">
</span>    // Create the executor for an in-process function with just one observer
    let mut executor = InProcessExecutor::new(
        &amp;mut harness,
        tuple_list!(observer),
        &amp;mut fuzzer,
        &amp;mut state,
        &amp;mut mgr,
    )
    .expect(&quot;Failed to create the Executor&quot;);
<span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Now that the fuzzer can observe which condition is satisfied, we need a way to rate an input as interesting (i.e. worth of addition to the corpus) based on this observation. Here comes the notion of Feedback.</p>
<p><strong>Feedback</strong> is part of the State and provides a way to rate input and its corresponding execution as interesting looking for the information in the observers. Feedbacks can maintain a cumulative state of the information seen so far in a metadata in the State, in our case it maintains the set of conditions satisfied in the previous runs.</p>
<p>We use <code>MaxMapFeedback</code>, a feedback that implements a novelty search over the map of the MapObserver. Basically, if there is a value in the observer's map that is greater than the maximum value registered so far for the same entry, it rates the input as interesting and updates its state.</p>
<p><strong>Objective Feedback</strong> is another kind of Feedback which decides if an input is a &quot;solution&quot;. It will save input to solutions(<code>./crashes</code> in our case) rather than corpus when the input is rated interesting. We use <code>CrashFeedback</code> to tell the fuzzer that if an input causes the program to crash it is a solution for us.</p>
<p>We need to update our State creation including the feedback state and the Fuzzer including the feedback and the objective:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    feedbacks::{CrashFeedback, MaxMapFeedback},
</span><span class="boring">    fuzzer::StdFuzzer,
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    observers::StdMapObserver,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">// Coverage map with explicit assignments due to the lack of instrumentation
</span><span class="boring">static mut SIGNALS: [u8; 16] = [0; 16];
</span><span class="boring">
</span><span class="boring">fn signals_set(idx: usize) {
</span><span class="boring">    unsafe { SIGNALS[idx] = 1 };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // The closure that we want to fuzz
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        signals_set(0); // set SIGNALS[0]
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            signals_set(1); // set SIGNALS[1]
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                signals_set(2); // set SIGNALS[2]
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // Create an observation channel using the signals map
</span><span class="boring">    let observer = unsafe { StdMapObserver::new(&quot;signals&quot;, &amp;mut SIGNALS) };
</span><span class="boring">
</span>    // Feedback to rate the interestingness of an input
    let mut feedback = MaxMapFeedback::new(&amp;observer);

    // A feedback to choose if an input is a solution or not
    let mut objective = CrashFeedback::new();

    // create a State from scratch
    let mut state = StdState::new(
        // RNG
        StdRand::with_seed(current_nanos()),
        // Corpus that will be evolved, we keep it in memory for performance
        InMemoryCorpus::new(),
        // Corpus in which we store solutions (crashes in this example),
        // on disk so the user can get them after stopping the fuzzer
        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
        &amp;mut feedback,
        &amp;mut objective,
    )
    .unwrap();
<span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span>
    // A fuzzer with feedbacks and a corpus scheduler
    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
<span class="boring">
</span><span class="boring">    // Create the executor for an in-process function with just one observer
</span><span class="boring">    let mut executor = InProcessExecutor::new(
</span><span class="boring">        &amp;mut harness,
</span><span class="boring">        tuple_list!(observer),
</span><span class="boring">        &amp;mut fuzzer,
</span><span class="boring">        &amp;mut state,
</span><span class="boring">        &amp;mut mgr,
</span><span class="boring">    )
</span><span class="boring">    .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Once again, you need to add the necessary <code>use</code> directives for this to work properly:</p>
<pre><pre class="playground"><code class="language-rust">extern crate libafl;
extern crate libafl_bolts;

use libafl::{
    corpus::{InMemoryCorpus, OnDiskCorpus},
    events::SimpleEventManager,
    executors::{inprocess::InProcessExecutor, ExitKind},
    feedbacks::{CrashFeedback, MaxMapFeedback},
    fuzzer::StdFuzzer,
    generators::RandPrintablesGenerator,
    inputs::{BytesInput, HasTargetBytes},
    monitors::SimpleMonitor,
    observers::StdMapObserver,
    schedulers::QueueScheduler,
    state::StdState,
};
use libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};
use std::path::PathBuf;
<span class="boring">
</span><span class="boring">// Coverage map with explicit assignments due to the lack of instrumentation
</span><span class="boring">static mut SIGNALS: [u8; 16] = [0; 16];
</span><span class="boring">
</span><span class="boring">fn signals_set(idx: usize) {
</span><span class="boring">    unsafe { SIGNALS[idx] = 1 };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // The closure that we want to fuzz
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        signals_set(0); // set SIGNALS[0]
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            signals_set(1); // set SIGNALS[1]
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                signals_set(2); // set SIGNALS[2]
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // Create an observation channel using the signals map
</span><span class="boring">    let observer = unsafe { StdMapObserver::new(&quot;signals&quot;, &amp;mut SIGNALS) };
</span><span class="boring">
</span><span class="boring">    // Feedback to rate the interestingness of an input
</span><span class="boring">    let mut feedback = MaxMapFeedback::new(&amp;observer);
</span><span class="boring">
</span><span class="boring">    // A feedback to choose if an input is a solution or not
</span><span class="boring">    let mut objective = CrashFeedback::new();
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut feedback,
</span><span class="boring">        &amp;mut objective,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function with just one observer
</span><span class="boring">    let mut executor = InProcessExecutor::new(
</span><span class="boring">        &amp;mut harness,
</span><span class="boring">        tuple_list!(observer),
</span><span class="boring">        &amp;mut fuzzer,
</span><span class="boring">        &amp;mut state,
</span><span class="boring">        &amp;mut mgr,
</span><span class="boring">    )
</span><span class="boring">    .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="the-actual-fuzzing"><a class="header" href="#the-actual-fuzzing">The actual fuzzing</a></h2>
<p>Now, we can run the program, but the outcome is not so different from the previous one as the random generator does not take into account what we save as interesting in the corpus. To do that, we need to plug a Mutator.</p>
<p><strong>Stages</strong> perform actions on individual inputs, taken from the corpus.
For instance, the <code>MutationalStage</code> executes the harness several times in a row, every time with mutated inputs.</p>
<p>As the last step, we create a MutationalStage that uses a mutator inspired by the havoc mutator of AFL.</p>
<pre><code class="language-rust ignore"><span class="boring">extern crate libafl;
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">
</span><span class="boring">use libafl::{
</span><span class="boring">    corpus::{InMemoryCorpus, OnDiskCorpus},
</span><span class="boring">    events::SimpleEventManager,
</span><span class="boring">    executors::{inprocess::InProcessExecutor, ExitKind},
</span><span class="boring">    feedbacks::{CrashFeedback, MaxMapFeedback},
</span><span class="boring">    fuzzer::{Fuzzer, StdFuzzer},
</span><span class="boring">    generators::RandPrintablesGenerator,
</span><span class="boring">    inputs::{BytesInput, HasTargetBytes},
</span><span class="boring">    monitors::SimpleMonitor,
</span><span class="boring">    mutators::scheduled::{havoc_mutations, StdScheduledMutator},
</span><span class="boring">    observers::StdMapObserver,
</span><span class="boring">    schedulers::QueueScheduler,
</span><span class="boring">    stages::mutational::StdMutationalStage,
</span><span class="boring">    state::StdState,
</span><span class="boring">};
</span><span class="boring">use libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">// Coverage map with explicit assignments due to the lack of instrumentation
</span><span class="boring">static mut SIGNALS: [u8; 16] = [0; 16];
</span><span class="boring">
</span><span class="boring">fn signals_set(idx: usize) {
</span><span class="boring">    unsafe { SIGNALS[idx] = 1 };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // The closure that we want to fuzz
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        signals_set(0); // set SIGNALS[0]
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            signals_set(1); // set SIGNALS[1]
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                signals_set(2); // set SIGNALS[2]
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // Create an observation channel using the signals map
</span><span class="boring">    let observer = unsafe { StdMapObserver::new(&quot;signals&quot;, &amp;mut SIGNALS) };
</span><span class="boring">
</span><span class="boring">    // Feedback to rate the interestingness of an input
</span><span class="boring">    let mut feedback = MaxMapFeedback::new(&amp;observer);
</span><span class="boring">
</span><span class="boring">    // A feedback to choose if an input is a solution or not
</span><span class="boring">    let mut objective = CrashFeedback::new();
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut feedback,
</span><span class="boring">        &amp;mut objective,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function with just one observer
</span><span class="boring">    let mut executor = InProcessExecutor::new(
</span><span class="boring">        &amp;mut harness,
</span><span class="boring">        tuple_list!(observer),
</span><span class="boring">        &amp;mut fuzzer,
</span><span class="boring">        &amp;mut state,
</span><span class="boring">        &amp;mut mgr,
</span><span class="boring">    )
</span><span class="boring">    .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">
</span>    // Setup a mutational stage with a basic bytes mutator
    let mutator = StdScheduledMutator::new(havoc_mutations());
    let mut stages = tuple_list!(StdMutationalStage::new(mutator));

    fuzzer
        .fuzz_loop(&amp;mut stages, &amp;mut executor, &amp;mut state, &amp;mut mgr)
        .expect(&quot;Error in the fuzzing loop&quot;);
<span class="boring">}
</span></code></pre>
<p><code>fuzz_loop</code> will request a testcase for each iteration to the fuzzer using the scheduler and then it will invoke the stage.</p>
<p>Again, we need to add the new <code>use</code> directives:</p>
<pre><code class="language-rust ignore">extern crate libafl;
extern crate libafl_bolts;

use libafl::{
    corpus::{InMemoryCorpus, OnDiskCorpus},
    events::SimpleEventManager,
    executors::{inprocess::InProcessExecutor, ExitKind},
    feedbacks::{CrashFeedback, MaxMapFeedback},
    fuzzer::{Fuzzer, StdFuzzer},
    generators::RandPrintablesGenerator,
    inputs::{BytesInput, HasTargetBytes},
    monitors::SimpleMonitor,
    mutators::scheduled::{havoc_mutations, StdScheduledMutator},
    observers::StdMapObserver,
    schedulers::QueueScheduler,
    stages::mutational::StdMutationalStage,
    state::StdState,
};
use libafl_bolts::{current_nanos, rands::StdRand, tuples::tuple_list, AsSlice};
use std::path::PathBuf;
<span class="boring">
</span><span class="boring">// Coverage map with explicit assignments due to the lack of instrumentation
</span><span class="boring">static mut SIGNALS: [u8; 16] = [0; 16];
</span><span class="boring">
</span><span class="boring">fn signals_set(idx: usize) {
</span><span class="boring">    unsafe { SIGNALS[idx] = 1 };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // The closure that we want to fuzz
</span><span class="boring">    let mut harness = |input: &amp;BytesInput| {
</span><span class="boring">        let target = input.target_bytes();
</span><span class="boring">        let buf = target.as_slice();
</span><span class="boring">        signals_set(0); // set SIGNALS[0]
</span><span class="boring">        if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
</span><span class="boring">            signals_set(1); // set SIGNALS[1]
</span><span class="boring">            if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
</span><span class="boring">                signals_set(2); // set SIGNALS[2]
</span><span class="boring">                if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
</span><span class="boring">                    panic!(&quot;=)&quot;);
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        ExitKind::Ok
</span><span class="boring">    };
</span><span class="boring">    // To test the panic:
</span><span class="boring">    let input = BytesInput::new(Vec::from(&quot;abc&quot;));
</span><span class="boring">    #[cfg(feature = &quot;panic&quot;)]
</span><span class="boring">    harness(&amp;input);
</span><span class="boring">
</span><span class="boring">    // Create an observation channel using the signals map
</span><span class="boring">    let observer = unsafe { StdMapObserver::new(&quot;signals&quot;, &amp;mut SIGNALS) };
</span><span class="boring">
</span><span class="boring">    // Feedback to rate the interestingness of an input
</span><span class="boring">    let mut feedback = MaxMapFeedback::new(&amp;observer);
</span><span class="boring">
</span><span class="boring">    // A feedback to choose if an input is a solution or not
</span><span class="boring">    let mut objective = CrashFeedback::new();
</span><span class="boring">
</span><span class="boring">    // create a State from scratch
</span><span class="boring">    let mut state = StdState::new(
</span><span class="boring">        // RNG
</span><span class="boring">        StdRand::with_seed(current_nanos()),
</span><span class="boring">        // Corpus that will be evolved, we keep it in memory for performance
</span><span class="boring">        InMemoryCorpus::new(),
</span><span class="boring">        // Corpus in which we store solutions (crashes in this example),
</span><span class="boring">        // on disk so the user can get them after stopping the fuzzer
</span><span class="boring">        OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
</span><span class="boring">        &amp;mut feedback,
</span><span class="boring">        &amp;mut objective,
</span><span class="boring">    )
</span><span class="boring">    .unwrap();
</span><span class="boring">
</span><span class="boring">    // The Monitor trait defines how the fuzzer stats are displayed to the user
</span><span class="boring">    let mon = SimpleMonitor::new(|s| println!(&quot;{s}&quot;));
</span><span class="boring">
</span><span class="boring">    // The event manager handles the various events generated during the fuzzing loop
</span><span class="boring">    // such as the notification of the addition of a new item to the corpus
</span><span class="boring">    let mut mgr = SimpleEventManager::new(mon);
</span><span class="boring">
</span><span class="boring">    // A queue policy to get testcasess from the corpus
</span><span class="boring">    let scheduler = QueueScheduler::new();
</span><span class="boring">
</span><span class="boring">    // A fuzzer with feedbacks and a corpus scheduler
</span><span class="boring">    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
</span><span class="boring">
</span><span class="boring">    // Create the executor for an in-process function with just one observer
</span><span class="boring">    let mut executor = InProcessExecutor::new(
</span><span class="boring">        &amp;mut harness,
</span><span class="boring">        tuple_list!(observer),
</span><span class="boring">        &amp;mut fuzzer,
</span><span class="boring">        &amp;mut state,
</span><span class="boring">        &amp;mut mgr,
</span><span class="boring">    )
</span><span class="boring">    .expect(&quot;Failed to create the Executor&quot;);
</span><span class="boring">
</span><span class="boring">    // Generator of printable bytearrays of max size 32
</span><span class="boring">    let mut generator = RandPrintablesGenerator::new(32);
</span><span class="boring">
</span><span class="boring">    // Generate 8 initial inputs
</span><span class="boring">    state
</span><span class="boring">        .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
</span><span class="boring">        .expect(&quot;Failed to generate the initial corpus&quot;);
</span><span class="boring">
</span><span class="boring">    // Setup a mutational stage with a basic bytes mutator
</span><span class="boring">    let mutator = StdScheduledMutator::new(havoc_mutations());
</span><span class="boring">    let mut stages = tuple_list!(StdMutationalStage::new(mutator));
</span><span class="boring">
</span><span class="boring">    fuzzer
</span><span class="boring">        .fuzz_loop(&amp;mut stages, &amp;mut executor, &amp;mut state, &amp;mut mgr)
</span><span class="boring">        .expect(&quot;Error in the fuzzing loop&quot;);
</span><span class="boring">}
</span></code></pre>
<p>After adding this code, we have a proper fuzzer, that can run and find the input that panics the function in less than a second.</p>
<pre><code class="language-console">$ cargo run
   Compiling baby_fuzzer v0.1.0 (/home/andrea/Desktop/baby_fuzzer)
    Finished dev [unoptimized + debuginfo] target(s) in 1.56s
     Running `target/debug/baby_fuzzer`
[New Testcase] clients: 1, corpus: 2, objectives: 0, executions: 1, exec/sec: 0
[LOG Debug]: Loaded 1 over 8 initial testcases
[New Testcase] clients: 1, corpus: 3, objectives: 0, executions: 804, exec/sec: 0
[New Testcase] clients: 1, corpus: 4, objectives: 0, executions: 1408, exec/sec: 0
thread 'main' panicked at '=)', src/main.rs:35:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Crashed with SIGABRT
Child crashed!
[Objective] clients: 1, corpus: 4, objectives: 1, executions: 1408, exec/sec: 0
Waiting for broker...
Bye!
</code></pre>
<p>As you can see, after the panic message, the <code>objectives</code> count of the log increased by one and you will find the crashing input in <code>crashes/</code>.</p>
<p>The complete code can be found in <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/baby_fuzzer"><code>./fuzzers/baby_fuzzer</code></a> alongside other <code>baby_</code> fuzzers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-examples"><a class="header" href="#more-examples">More Examples</a></h1>
<p>Examples can be found under <code>./fuzzer</code>.</p>
<table><thead><tr><th>fuzzer name</th><th>usage</th></tr></thead><tbody>
<tr><td>baby_fuzzer_gramatron</td><td><a href="https://github.com/HexHive/Gramatron">Gramatron</a> is a fuzzer that uses <strong>grammar automatons</strong> in conjunction with aggressive mutation operators to synthesize complex bug triggers</td></tr>
<tr><td>baby_fuzzer_grimoire</td><td><a href="https://www.usenix.org/system/files/sec19-blazytko.pdf">Grimoire</a> is a fully automated coverage-guided fuzzer which works <strong>without any form of human interaction or pre-configuration</strong></td></tr>
<tr><td>baby_fuzzer_nautilus</td><td><a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_04A-3_Aschermann_paper.pdf">nautilus</a> is a <strong>coverage guided, grammar based</strong> fuzzer</td></tr>
<tr><td>baby_fuzzer_tokens</td><td>basic <strong>token level</strong> fuzzer with token level mutations</td></tr>
<tr><td>baby_fuzzer_with_forkexecutor</td><td>example for <strong>InProcessForkExecutor</strong></td></tr>
<tr><td>baby_no_std</td><td>a minimalistic example how to create a libafl based fuzzer that works on <strong><code>no_std</code></strong> environments like TEEs, Kernels or on bare metal</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>LibAFL is designed around some core concepts that we think can effectively abstract most of the other fuzzers designs.</p>
<p>Here, we discuss these concepts and provide some examples related to other fuzzers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observer"><a class="header" href="#observer">Observer</a></h1>
<p>An Observer is an entity that provides an information observed during the execution of the program under test to the fuzzer.</p>
<p>The information contained in the Observer is not preserved across executions, but it may be serialized and passed on to other nodes if an <code>Input</code> is considered <code>interesting</code>, and added to the <code>Corpus</code>.</p>
<p>As an example, the coverage map, filled during the execution to report the executed edges used by fuzzers such as AFL and <code>HonggFuzz</code> can be considered an observation. Another <code>Observer</code> can collect the time spent executing a run, the program output, or a more advanced observation, like maximum stack depth at runtime.
This information is an observation of a dynamic property of the program.</p>
<p>In terms of code, in the library this entity is described by the <a href="https://docs.rs/libafl/0/libafl/observers/trait.Observer.html"><code>Observer</code></a> trait.</p>
<p>In addition to holding the volatile data connected with the last execution of the target, the structures implementing this trait can define some execution hooks that are executed before and after each fuzz case. In these hooks, the observer can modify the fuzzer's state.</p>
<p>The fuzzer will act based on these observers through a <a href="core_concepts/./feedback.html"><code>Feedback</code></a>, that reduces the observation to the choice if a testcase is <code>interesting</code> for the fuzzer, or not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executor"><a class="header" href="#executor">Executor</a></h1>
<p>In different fuzzers, this concept of executing the program under test means each run is now always the same.
For instance, for in-memory fuzzers like libFuzzer an execution is a call to an harness function, for hypervisor-based fuzzers like <a href="https://github.com/IntelLabs/kAFL">kAFL</a> instead an entire operating system is started from a snapshot for each run.</p>
<p>In our model, an Executor is the entity that defines not only how to execute the target, but all the volatile operations that are related to just a single run of the target.</p>
<p>So the Executor is for instance responsible to inform the program about the input that the fuzzer wants to use in the run, writing to a memory location for instance or passing it as a parameter to the harness function.</p>
<p>In our model, it can also hold a set of Observers connected with each execution.</p>
<p>In Rust, we bind this concept to the <a href="https://docs.rs/libafl/0/libafl/executors/trait.Executor.html"><code>Executor</code></a> trait. A structure implementing this trait must implement <a href="https://docs.rs/libafl/0/libafl/executors/trait.HasObservers.html"><code>HasObservers</code></a> too if wants to hold a set of Observers.</p>
<p>By default, we implement some commonly used Executors such as <a href="https://docs.rs/libafl/0/libafl/executors/inprocess/struct.InProcessExecutor.html"><code>InProcessExecutor</code></a> in which the target is a harness function providing in-process crash detection. Another Executor is the <a href="https://docs.rs/libafl/0/libafl/executors/forkserver/struct.ForkserverExecutor.html"><code>ForkserverExecutor</code></a> that implements an AFL-like mechanism to spawn child processes to fuzz.</p>
<p>A common pattern when creating an Executor is wrapping an existing one, for instance <a href="https://docs.rs/libafl/0.6.1/libafl/executors/timeout/struct.TimeoutExecutor.html"><code>TimeoutExecutor</code></a> wraps an executor and installs a timeout callback before calling the original <code>run</code> function of the wrapped executor.</p>
<h2 id="inprocessexecutor"><a class="header" href="#inprocessexecutor">InProcessExecutor</a></h2>
<p>Let's begin with the base case; <code>InProcessExecutor</code>.
This executor executes the harness program (function) inside the fuzzer process.</p>
<p>When you want to execute the harness as fast as possible, you will most probably want to use this <code>InprocessExecutor</code>.</p>
<p>One thing to note here is, when your harness is likely to have heap corruption bugs, you want to use another allocator so that corrupted heap does not affect the fuzzer itself. (For example, we adopt MiMalloc in some of our fuzzers.). Alternatively you can compile your harness with address sanitizer to make sure you can catch these heap bugs.</p>
<h2 id="forkserverexecutor"><a class="header" href="#forkserverexecutor">ForkserverExecutor</a></h2>
<p>Next, we'll take a look at the <code>ForkserverExecutor</code>. In this case, it is <code>afl-cc</code> (from AFLplusplus/AFLplusplus) that compiles the harness code, and therefore, we can't use <code>EDGES_MAP</code> anymore. Fortunately we have <a href="https://github.com/AFLplusplus/AFLplusplus/blob/2e15661f184c77ac1fbb6f868c894e946cbb7f17/instrumentation/afl-compiler-rt.o.c#L270"><em>a way</em></a> to tell the forkserver which map to record the coverage in.</p>
<p>As you can see from the forkserver example,</p>
<pre><code class="language-rust ignore">//Coverage map shared between observer and executor
let mut shmem = StdShMemProvider::new().unwrap().new_shmem(MAP_SIZE).unwrap();
//let the forkserver know the shmid
shmem.write_to_env(&quot;__AFL_SHM_ID&quot;).unwrap();
let mut shmem_buf = shmem.as_mut_slice();
</code></pre>
<p>Here we make a shared memory region; <code>shmem</code>, and write this to environmental variable <code>__AFL_SHM_ID</code>. Then the instrumented binary, or the forkserver, finds this shared memory region (from the aforementioned env var) to record its coverage. On your fuzzer side, you can pass this shmem map to your <code>Observer</code> to obtain coverage feedbacks combined with any <code>Feedback</code>.</p>
<p>Another feature of the <code>ForkserverExecutor</code> to mention is the shared memory testcases. In normal cases, the mutated input is passed between the forkserver and the instrumented binary via <code>.cur_input</code> file. You can improve your forkserver fuzzer's performance by passing the input with shared memory.</p>
<p>If the target is configured to use shared memory testcases, the <code>ForkserverExecutor</code> will notice this during the handshake and will automatically set up things accordingly.
See AFL++'s <a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md#5-shared-memory-fuzzing"><em>documentation</em></a> or the fuzzer example in <code>forkserver_simple/src/program.c</code> for reference.</p>
<h2 id="inprocessforkexecutor"><a class="header" href="#inprocessforkexecutor">InprocessForkExecutor</a></h2>
<p>Finally, we'll talk about the <code>InProcessForkExecutor</code>.
<code>InProcessForkExecutor</code> has only one difference from <code>InprocessExecutor</code>; It forks before running the harness and that's it.</p>
<p>But why do we want to do so? Well, under some circumstances, you may find your harness pretty unstable or your harness wreaks havoc on the global states. In this case, you want to fork it before executing the harness runs in the child process so that it doesn't break things.</p>
<p>However, we have to take care of the shared memory, it's the child process that runs the harness code and writes the coverage to the map.</p>
<p>We have to make the map shared between the parent process and the child process, so we'll use shared memory again. You should compile your harness with <code>pointer_maps</code> (for <code>libafl_targets</code>) features enabled, this way, we can have a pointer; <code>EDGES_MAP_PTR</code> that can point to any coverage map.</p>
<p>On your fuzzer side, you can allocate a shared memory region and make the <code>EDGES_MAP_PTR</code> point to your shared memory.</p>
<pre><code class="language-rust ignore">let mut shmem;
unsafe{
    shmem = StdShMemProvider::new().unwrap().new_shmem(MAX_EDGES_NUM).unwrap();
}
let shmem_buf = shmem.as_mut_slice();
unsafe{
    EDGES_PTR = shmem_buf.as_ptr();
}
</code></pre>
<p>Again, you can pass this shmem map to your <code>Observer</code> and <code>Feedback</code> to obtain coverage feedbacks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feedback"><a class="header" href="#feedback">Feedback</a></h1>
<p>The Feedback is an entity that classifies the outcome of an execution of the program under test as interesting or not.
Typically, if an execution is interesting, the corresponding input used to feed the target program is added to a corpus.</p>
<p>Most of the time, the notion of Feedback is deeply linked to the Observer, but they are different concepts.</p>
<p>The Feedback, in most of the cases, processes the information reported by one or more observers to decide if the execution is interesting.
The concept of &quot;interestingness&quot; is abstract, but typically it is related to a novelty search (i.e. interesting inputs are those that reach a previously unseen edge in the control flow graph).</p>
<p>As an example, given an Observer that reports all the sizes of memory allocations, a maximization Feedback can be used to maximize these sizes to sport pathological inputs in terms of memory consumption.</p>
<p>In terms of code, the library offers the <a href="https://docs.rs/libafl/0/libafl/feedbacks/trait.Feedback.html"><code>Feedback</code></a> trait.
It is used to implement functors that, given the state of the observers from the last execution, tells if the execution was interesting.
So to speak, it reduces the observations to a boolean result of <a href="https://docs.rs/libafl/0/libafl/feedbacks/trait.Feedback.html#tymethod.is_interesting"><code>is_interesting</code></a> - or not.
For this, a <code>Feedback</code> can store anything it wants to persist in the fuzzers's state.
This might be, for instance, the cumulative map of all edges seen so far, in the case of a feedback based on edge coverage.
This can be achieved by adding <code>Metadata</code> in <a href="https://docs.rs/libafl/0/libafl/feedbacks/trait.Feedback.html#method.init_state"><code>init_state</code></a> and accessing it later in <code>is_interesting</code>.
<code>Feedback</code> can also add custom metadata to a newly created <a href="https://docs.rs/libafl/0/libafl/corpus/testcase/struct.Testcase.html"><code>Testcase</code></a> using <a href="https://docs.rs/libafl/0.10.1/libafl/feedbacks/trait.Feedback.html#method.append_metadata"><code>append_metadata</code></a>.</p>
<p>Multiple Feedbacks can be combined into a boolean expression, considering for instance an execution as interesting if it triggers new code paths or execute in less time compared to the average execution time using <a href="https://docs.rs/libafl/*/libafl/macro.feedback_or.html"><code>feedback_or</code></a>.</p>
<p>On top, logic operators like <code>feedback_or</code> and <code>feedback_and</code> have a <code>_fast</code> variant (e.g. <code>feedback_or_fast</code>) where the second feedback will not be evaluated, if the value of the first feedback operand already answers the <code>interestingness</code> question so as to save precious performance.</p>
<p>Using <code>feedback_and_fast</code> in combination with <a href="https://docs.rs/libafl/*/libafl/feedbacks/enum.ConstFeedback.html#method.new"><code>ConstFeedback</code></a>, certain feedbacks can be disabled dynamically.</p>
<h2 id="objectives"><a class="header" href="#objectives">Objectives</a></h2>
<p>While feedbacks are commonly used to decide if an <a href="https://docs.rs/libafl/*/libafl/inputs/trait.Input.html"><code>Input</code></a> should be kept for future mutations, they serve a double-purpose, as so-called <code>Objective Feedbacks</code>.
In this case, the <code>interestingness</code> of a feedback indicates if an <code>Objective</code> has been hit.
Commonly, these objectives would be a crash or a timeout, but they can also be used to detect if specific parts of the program have been reached, for sanitization, or a differential fuzzing success.
Objectives use the same trait as a normal <a href="https://docs.rs/libafl/0/libafl/feedbacks/trait.Feedback.html"><code>Feedback</code></a> and the implementations can be used interchangeably.</p>
<p>The only difference is that <code>interesting</code> Objectives won't be mutated further, and are counted as <code>Solutions</code>, a successful fuzzing campaign.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input"><a class="header" href="#input">Input</a></h1>
<p>Formally, the input of a program is the data taken from external sources that affect the program behavior.</p>
<p>In our model of an abstract fuzzer, we define the Input as the internal representation of the program input (or a part of it).</p>
<p>In the straightforward case, the input of the program is a byte array and in fuzzers such as AFL we store and manipulate exactly these byte arrays.</p>
<p>But it is not always the case. A program can expect inputs that are not linear byte arrays (e.g. a sequence of syscalls forming a use case or protocol) and the fuzzer does not represent the Input in the same way that the program consumes it.</p>
<p>In case of a grammar fuzzer for instance, the Input is generally an Abstract Syntax Tree because it is a data structure that can be easily manipulated while maintaining the validity, but the program expects a byte array as input, so just before the execution, the tree is serialized to a sequence of bytes.</p>
<p>In the Rust code, an <a href="https://docs.rs/libafl/*/libafl/inputs/trait.Input.html"><code>Input</code></a> is a trait that can be implemented only by structures that are serializable and have only owned data as fields.</p>
<p>While most fuzzers use a normal <code>BytesInput</code>, more advanced ones use inputs that include special inputs for grammar fuzzing (<a href="https://docs.rs/libafl/*/libafl/inputs/gramatron/struct.GramatronInput.html">GramatronInput</a> or <code>NautilusInput</code> on Rust nightly), as well as the token-level <a href="https://docs.rs/libafl/*/libafl/inputs/encoded/struct.EncodedInput.html">EncodedInput</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="corpus"><a class="header" href="#corpus">Corpus</a></h1>
<p>The Corpus is where testcases are stored. We define a Testcase as an Input and a set of related metadata like execution time for instance.</p>
<p>A Corpus can store testcases in different ways, for example on disk, or in memory, or implement a cache to speedup on disk storage.</p>
<p>Usually, a testcase is added to the Corpus when it is considered as interesting, but a Corpus is used also to store testcases that fulfill an objective (like crashing the program under test for instance).</p>
<p>Related to the Corpus is the way in which the next testcase (the fuzzer would ask for) is retrieved from the Corpus. The taxonomy for this handling in LibAFL is CorpusScheduler, the entity representing the policy to pop testcases from the Corpus, in a FIFO fashion for instance.</p>
<p>Speaking about the code, <a href="https://docs.rs/libafl/0/libafl/corpus/trait.Corpus.html"><code>Corpus</code></a> and <a href="https://docs.rs/libafl/0/libafl/corpus/trait.CorpusScheduler.html"><code>CorpusScheduler</code></a> are traits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutator"><a class="header" href="#mutator">Mutator</a></h1>
<p>The Mutator is an entity that takes one or more Inputs and generates a new instance of Input derived by its inputs.</p>
<p>Mutators can be composed, and they are generally linked to a specific Input type.</p>
<p>There can be, for instance, a Mutator that applies more than a single type of mutation to the input. Consider a generic Mutator for a byte stream, bit flip is just one of the possible mutations but not the only one, there is also, for instance, the random replacement of a byte of the copy of a chunk.</p>
<p>In LibAFL, <a href="https://docs.rs/libafl/*/libafl/mutators/trait.Mutator.html"><code>Mutator</code></a> is a trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generator"><a class="header" href="#generator">Generator</a></h1>
<p>A Generator is a component designed to generate an Input from scratch.</p>
<p>Typically, a random generator is used to generate random inputs.</p>
<p>Generators are traditionally less used in Feedback-driven Fuzzing, but there are exceptions, like Nautilus, that uses a Grammar generator to create the initial corpus and a sub-tree Generator as a mutation of its grammar Mutator.</p>
<p>In the code, <a href="https://docs.rs/libafl/0/libafl/generators/trait.Generator.html"><code>Generator</code></a> is a trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stage"><a class="header" href="#stage">Stage</a></h1>
<p>A Stage is an entity that operates on a single Input received from the Corpus.</p>
<p>For instance, a Mutational Stage, given an input of the corpus, applies a Mutator and executes the generated input one or more times. How many times this has to be done can be scheduled, AFL for instance uses a performance score of the input to choose how many times the havoc mutator should be invoked. This can depend also on other parameters, for instance, the length of the input if we want to just apply a sequential bitflip, or a fixed value.</p>
<p>A stage can also be an analysis stage, for instance, the Colorization stage of Redqueen that aims to introduce more entropy in a testcase or the Trimming stage of AFL that aims to reduce the size of a testcase.</p>
<p>There are several stages in the LibAFL codebase implementing the <a href="https://docs.rs/libafl/*/libafl/stages/trait.Stage.html"><code>Stage</code></a> trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>In this chapter, we discuss how we designed the library taking into account the core concepts while allowing code reuse and extensibility.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The LibAFL architecture is built around some entities to allow code reuse and low-cost abstractions.</p>
<p>Initially, we started thinking about implementing LibAFL in a traditional Object-Oriented language, like C++. When we switched to Rust, we immediately changed our idea as we realized that, we can build the library using a more rust-y approach, namely the one described in <a href="https://kyren.github.io/2018/09/14/rustconf-talk.html">this blogpost</a> about game design in Rust.</p>
<p>The LibAFL code reuse mechanism is based on components, rather than sub-classes, but there are still some OOP patterns in the library.</p>
<p>Thinking about similar fuzzers, you can observe that most of the time the data structures that are modified are the ones related to testcases and the fuzzer global state.</p>
<p>Beside the entities previously described, we introduce the <a href="https://docs.rs/libafl/0.6/libafl/corpus/testcase/struct.Testcase.html"><code>Testcase</code></a> and <a href="https://docs.rs/libafl/0.6/libafl/state/struct.StdState.html"><code>State</code></a> entities. The Testcase is a container for an Input stored in the Corpus and its metadata (so, in the implementation, the Corpus stores Testcases) and the State contains all the metadata that are evolved while running the fuzzer, Corpus included.</p>
<p>The State, in the implementation, contains only owned objects that are serializable, and it is serializable itself. Some fuzzers may want to serialize their state when pausing or just, when doing in-process fuzzing, serialize on crash and deserialize in the new process to continue to fuzz with all the metadata preserved.</p>
<p>Additionally, we group the entities that are &quot;actions&quot;, like the <code>CorpusScheduler</code> and the <code>Feedbacks</code>, in a common place, the <a href="https://docs.rs/libafl/*/libafl/fuzzer/struct.StdFuzzer.html">`Fuzzer'</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metadata"><a class="header" href="#metadata">Metadata</a></h1>
<p>A metadata in LibAFL is a self-contained structure that holds associated data to the State or to a Testcase.</p>
<p>In terms of code, a metadata can be defined as a Rust struct registered in the SerdeAny register.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate libafl_bolts;
</span><span class="boring">extern crate serde;
</span>
use libafl_bolts::SerdeAny;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, SerdeAny)]
pub struct MyMetadata {
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>The struct must be static, so it cannot hold references to borrowed objects.</p>
<p>As an alternative to <code>derive(SerdeAny)</code> which is a proc-macro in <code>libafl_derive</code> the user can use <code>libafl_bolts::impl_serdeany!(MyMetadata);</code>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Metadata objects are primarly intended to be used inside <a href="https://docs.rs/libafl/0.5.0/libafl/bolts/serdeany/serdeany_registry/struct.SerdeAnyMap.html"><code>SerdeAnyMap</code></a> and <a href="https://docs.rs/libafl/0.5.0/libafl/bolts/serdeany/serdeany_registry/struct.NamedSerdeAnyMap.html"><code>NamedSerdeAnyMap</code></a>.</p>
<p>With these maps, the user can retrieve instances by type (and name). Internally, the instances are stored as SerdeAny trait objects.</p>
<p>Structs that want to have a set of metadata must implement the <a href="https://docs.rs/libafl/0.5.0/libafl/state/trait.HasMetadata.html"><code>HasMetadata</code></a> trait.</p>
<p>By default, Testcase and State implement it and hold a SerdeAnyMap testcase.</p>
<h2 id="deserialization"><a class="header" href="#deserialization">(De)Serialization</a></h2>
<p>We are interested to store State's Metadata to not lose them in case of crash or stop of a fuzzer. To do that, they must be serialized and unserialized using Serde.</p>
<p>As Metadata is stored in a SerdeAnyMap as trait objects, they cannot be deserialized using Serde by default.</p>
<p>To cope with this problem, in LibAFL each SerdeAny struct must be registered in a global registry that keeps track of types and allows the (de)serialization of the registered types.</p>
<p>Normally, the <code>impl_serdeany</code> macro does that for the user creating a constructor function that fills the registry. However, when using LibAFL in no_std mode, this operation must be carried out manually before any other operation in the <code>main</code> function.</p>
<p>To do that, the developer needs to know each metadata type that is used inside the fuzzer and call <code>RegistryBuilder::register::&lt;MyMetadata&gt;()</code> for each of them at the beginning of <code>main</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-libafl-09-to-09"><a class="header" href="#migrating-from-libafl-09-to-09">Migrating from LibAFL &lt;0.9 to 0.9</a></h1>
<p>Internal APIs of LibAFL have changed in version 0.9 to prefer associated types in cases where components were &quot;fixed&quot; to
particular versions of other components. As a result, many existing custom components will not be compatible between
versions prior to 0.9 and version 0.9.</p>
<h2 id="reasons-for-this-change"><a class="header" href="#reasons-for-this-change">Reasons for this change</a></h2>
<p>When implementing a trait with a generic, it is possible to have more than one instantiation of that generic trait. As a
result, everywhere where consistency across generic types was required to implement a trait, it needed to be properly
and explicitly constrained at every point. This led to <code>impl</code>s which were at best difficult to debug and, at worst,
incorrect and caused confusing bugs for users.</p>
<p>For example, consider the  <code>MapCorpusMinimizer</code> implementation (from &lt;0.9) below:</p>
<pre><code class="language-rust ignore">impl&lt;E, I, O, S, TS&gt; CorpusMinimizer&lt;I, S&gt; for MapCorpusMinimizer&lt;E, I, O, S, TS&gt;
where
    E: Copy + Hash + Eq,
    I: Input,
    for&lt;'a&gt; O: MapObserver&lt;Entry = E&gt; + AsIter&lt;'a, Item = E&gt;,
    S: HasMetadata + HasCorpus&lt;I&gt;,
    TS: TestcaseScore&lt;I, S&gt;,
{
    fn minimize&lt;CS, EX, EM, OT, Z&gt;(
        &amp;self,
        fuzzer: &amp;mut Z,
        executor: &amp;mut EX,
        manager: &amp;mut EM,
        state: &amp;mut S,
    ) -&gt; Result&lt;(), Error&gt;
    where
        CS: Scheduler&lt;I, S&gt;,
        EX: Executor&lt;EM, I, S, Z&gt; + HasObservers&lt;I, OT, S&gt;,
        EM: EventManager&lt;EX, I, S, Z&gt;,
        OT: ObserversTuple&lt;S&gt;,
        Z: Evaluator&lt;EX, EM, I, S&gt; + HasScheduler&lt;CS, I, S&gt;,
    {
        // --- SNIP ---
    }
}
</code></pre>
<p>It was previously necessary to constrain every generic using a slew of other generics; above, it is necessary to
constrain the input type (<code>I</code>) for every generic, despite the fact that this was already made clear by the state (<code>S</code>)
and that the input will necessarily be the same over every implementation for that type.</p>
<p>Below is the same code, but with the associated types changes (note that some generic names have changed):</p>
<pre><code class="language-rust ignore">impl&lt;E, O, T, TS&gt; CorpusMinimizer&lt;E&gt; for MapCorpusMinimizer&lt;E, O, T, TS&gt;
where
    E: UsesState,
    for&lt;'a&gt; O: MapObserver&lt;Entry = T&gt; + AsIter&lt;'a, Item = T&gt;,
    E::State: HasMetadata + HasCorpus,
    T: Copy + Hash + Eq,
    TS: TestcaseScore&lt;E::State&gt;,
{
    fn minimize&lt;CS, EM, Z&gt;(
        &amp;self,
        fuzzer: &amp;mut Z,
        executor: &amp;mut E,
        manager: &amp;mut EM,
        state: &amp;mut E::State,
    ) -&gt; Result&lt;(), Error&gt;
    where
        E: Executor&lt;EM, Z&gt; + HasObservers,
        CS: Scheduler&lt;State=E::State&gt;,
        EM: UsesState&lt;State=E::State&gt;,
        Z: HasScheduler&lt;CS, State=E::State&gt;,
    {
        // --- SNIP ---
    }
}
</code></pre>
<p>The executor is constrained to <code>EM</code> and <code>Z</code>, with each of their respective states being constrained to <code>E</code>'s state. It
is no longer necessary to explicitly define a generic for the input type, the state type, or the generic type, as these
are all present as associated types for <code>E</code>. Additionally, we don't even need to specify any details about the observers
(<code>OT</code> in the previous version) as the type does not need to be constrained and is not shared by other types.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>You are affected by this change if:</p>
<ul>
<li>You specified explicit generics for a type (e.g., <code>MaxMapFeedback::&lt;_, (), _&gt;::new(...)</code>)</li>
<li>You implemented a custom component (e.g., <code>Mutator</code>, <code>Executor</code>, <code>State</code>, <code>Fuzzer</code>, <code>Feedback</code>, <code>Observer</code>, etc.)</li>
</ul>
<p>If you did neither of these, congrats! You are likely unaffected by these changes.</p>
<h3 id="migrating-explicit-generics"><a class="header" href="#migrating-explicit-generics">Migrating explicit generics</a></h3>
<p>Migrating specific generics should be a quite simple process; you should review the API documentation for details on the
order of generics and replace them accordingly. Generally speaking, it should no longer be necessary to specify these
generics.</p>
<p>See <code>fuzzers/</code> for examples of these changes.</p>
<h3 id="migrating-component-types"><a class="header" href="#migrating-component-types">Migrating component types</a></h3>
<p>If you implemented a Mutator, Executor, State, or another kind of component, you must update your implementation. The
main changes to the API are in the use of &quot;Uses*&quot; for associated types.</p>
<p>In many scenarios, Input, Observer, and State generics have been moved into traits with associated types (namely,
&quot;UsesInput&quot;, &quot;UsesObservers&quot;, and &quot;UsesState&quot;. These traits are required for many existing traits now and are very
straightforward to implement. In a majority of cases, you will have generics on your custom implementation or a fixed
type to implement this with. Thankfully, Rust will let you know when you need to implement this type.</p>
<p>As an example, <code>InMemoryCorpus</code> before 0.9 looked like this:</p>
<pre><code class="language-rust ignore">#[derive(Default, Serialize, Deserialize, Clone, Debug)]
#[serde(bound = &quot;I: serde::de::DeserializeOwned&quot;)]
pub struct InMemoryCorpus&lt;I&gt;
where
    I: Input,
{
    entries: Vec&lt;RefCell&lt;Testcase&lt;I&gt;&gt;&gt;,
    current: Option&lt;usize&gt;,
}

impl&lt;I&gt; Corpus&lt;I&gt; for InMemoryCorpus&lt;I&gt;
where
    I: Input,
{
    // --- SNIP ---
}
</code></pre>
<p>After 0.9, all <code>Corpus</code> implementations are required to implement <code>UsesInput</code>. Also <code>Corpus</code> no longer has a generic for
the input type (as it is now provided by the UsesInput impl). The migrated implementation is shown below:</p>
<pre><code class="language-rust ignore">#[derive(Default, Serialize, Deserialize, Clone, Debug)]
#[serde(bound = &quot;I: serde::de::DeserializeOwned&quot;)]
pub struct InMemoryCorpus&lt;I&gt;
where
    I: Input,
{
    entries: Vec&lt;RefCell&lt;Testcase&lt;I&gt;&gt;&gt;,
    current: Option&lt;usize&gt;,
}

impl&lt;I&gt; UsesInput for InMemoryCorpus&lt;I&gt;
where
    I: Input,
{
    type Input = I;
}

impl&lt;I&gt; Corpus for InMemoryCorpus&lt;I&gt;
where
    I: Input,
{
    // --- SNIP ---
}
</code></pre>
<p>Now, <code>Corpus</code> cannot be accidentally implemented for another type other than that specified by <code>InMemoryCorpus</code>, as it
is fixed to the associated type for <code>UsesInput</code>.</p>
<p>A more complex example of migration can be found in the &quot;Reasons for this change&quot; section of this document.</p>
<h2 id="observer-changes"><a class="header" href="#observer-changes">Observer Changes</a></h2>
<p>Additionally, we changed the Observer API, as the API in 0.8 led to undefined behavior.
At the same time, we used the change to simplify the common case: creating an <code>StdMapObserver</code>
from libafl_target's <code>EDGES_MAP</code>.
In the future, instead of using:</p>
<pre><code class="language-rust ignore">let edges = unsafe { &amp;mut EDGES_MAP[0..MAX_EDGES_NUM] };
let edges_observer = StdMapObserver::new(&quot;edges&quot;, edges);
</code></pre>
<p>creating the edges observer is as simple as using the new <code>std_edges_map_observer</code> function.</p>
<pre><code class="language-rust ignore">let edges_observer = unsafe { std_edges_map_observer(&quot;edges&quot;) };
</code></pre>
<p>Alternatively, <code>StdMapObserver::new</code> will still work, but now the whole method is marked as <code>unsafe</code>.
The reason is that the caller has to make sure <code>EDGES_MAP</code> (or other maps) are not moved or freed in memory,
for the lifetime of the <code>MapObserver</code>.
This means that the buffer should either be <code>static</code> or <code>Pin</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-libafl-011-to-011"><a class="header" href="#migrating-from-libafl-011-to-011">Migrating from LibAFL &lt;0.11 to 0.11</a></h1>
<p>We moved the old <code>libafl::bolts</code> module to its own crate called <code>libafl_bolts</code>.
For this, imports for types in LibAFL bolts have changed in version 0.11, everything else should remain the same.</p>
<h2 id="reasons-for-this-change-1"><a class="header" href="#reasons-for-this-change-1">Reasons for This Change</a></h2>
<p>With the change we can now use a lot of low-level features of LibAFL for projects that are unrelated to fuzzing, or just completely different to LibAFL.
Some cross-platform things in bolts include</p>
<ul>
<li>SerdeAnyMap: a map that stores and retrieves elements by type and is serializable and deserializable</li>
<li>ShMem: A cross-platform (Windows, Linux, Android, MacOS) shared memory implementation</li>
<li>LLMP: A fast, lock-free IPC mechanism via SharedMap</li>
<li>Core_affinity: A maintained version of <code>core_affinity</code> that can be used to get core information and bind processes to cores</li>
<li>Rands: Fast random number generators for fuzzing (like <a href="http://www.romu-random.org/">RomuRand</a>)</li>
<li>MiniBSOD: get and print information about the current process state including important registers.</li>
<li>Tuples: Haskel-like compile-time tuple lists</li>
<li>Os: OS specific stuff like signal handling, windows exception handling, pipes, and helpers for <code>fork</code></li>
</ul>
<h2 id="what-changed"><a class="header" href="#what-changed">What changed</a></h2>
<p>You will need to move all <code>libafl::bolts::</code> imports to <code>libafl_bolts:::</code> and add the crate dependency in your Cargo.toml (and specify feature flags there).
As only exception, the <code>libafl::bolts::launcher::Launcher</code> has moved to <code>libafl::events::launcher::Launcher</code> since it has fuzzer and <code>EventManager</code> specific code.
If you are using <code>prelude</code>, you may need to also ad <code>libafl_bolts::prelude</code>.</p>
<p>That's it.
Enjoy using <code>libafl_bolts</code> in other projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h1>
<p>LibAFL offers a standard mechanism for message passing between processes and machines with a low overhead.
We use message passing to inform the other connected clients/fuzzers/nodes about new testcases, metadata, and statistics about the current run.
Depending on individual needs, LibAFL can also write testcase contents to disk, while still using events to notify other fuzzers, using the <code>CachedOnDiskCorpus</code> or similar.</p>
<p>In our tests, message passing scales very well to share new testcases and metadata between multiple running fuzzer instances for multi-core fuzzing.
Specifically, it scales <em>a lot</em> better than using memory locks on a shared corpus, and <em>a lot</em> better than sharing the testcases via the filesystem, as AFL traditionally does.
Think &quot;all cores are green&quot; in <code>htop</code>, aka., no kernel interaction.</p>
<p>The <code>EventManager</code> interface is used to send Events over the wire using <code>Low Level Message Passing</code>, a custom message passing mechanism over shared memory or TCP.</p>
<h2 id="low-level-message-passing-llmp"><a class="header" href="#low-level-message-passing-llmp">Low Level Message Passing (LLMP)</a></h2>
<p>LibAFL comes with a reasonably lock-free message passing mechanism that scales well across cores and, using its <em>broker2broker</em> mechanism, even to connected machines via TCP.
Most example fuzzers use this mechanism, and it is the best <code>EventManager</code> if you want to fuzz on more than a single core.
In the following, we will describe the inner workings of <code>LLMP</code>.</p>
<p><code>LLMP</code> has one <code>broker</code> process that can forward messages sent by any client process to all other clients.
The broker can also intercept and filter the messages it receives instead of forwarding them.
A common use-case for messages filtered by the broker are the status messages sent from each client to the broker directly.
The broker used this information to paint a simple UI, with up-to-date information about all clients, however the other clients don't need to receive this information.</p>
<h3 id="speedy-local-messages-via-shared-memory"><a class="header" href="#speedy-local-messages-via-shared-memory">Speedy Local Messages via Shared Memory</a></h3>
<p>Throughout LibAFL, we use a wrapper around different operating system's shared maps, called <code>ShMem</code>.
Shared maps, called shared memory for the sake of not colliding with Rust's <code>map()</code> functions, are the backbone of <code>LLMP</code>.
Each client, usually a fuzzer trying to share stats and new testcases, maps an outgoing <code>ShMem</code> map.
With very few exceptions, only this client writes to this map, therefore, we do not run in race conditions and can live without locks.
The broker reads from all client's <code>ShMem</code> maps.
It periodically checks all incoming client maps and then forwards new messages to its outgoing broadcast-<code>ShMem</code>, mapped by all connected clients.</p>
<p>To send new messages, a client places a new message at the end of their shared memory and then updates a static field to notify the broker.
Once the outgoing map is full, the sender allocates a new <code>ShMem</code> using the respective <code>ShMemProvider</code>.
It then sends the information needed to map the newly-allocated page in connected processes to the old page, using an end of page (<code>EOP</code>) message.
Once the receiver maps the new page, it flags it as safe for unmapping by the sending process (to avoid race conditions if we have more than a single EOP in a short time), and then continues to read from the new <code>ShMem</code>.</p>
<p>The schema for client's maps to the broker is as follows:</p>
<pre><code class="language-text">[client0]        [client1]    ...    [clientN]
  |                  |                 /
[client0_out] [client1_out] ... [clientN_out]
  |                 /                /
  |________________/                /
  |________________________________/
 \|/
[broker]
</code></pre>
<p>The broker loops over all incoming maps, and checks for new messages.
On <code>std</code> builds, the broker will sleep a few milliseconds after a loop, since we do not need the messages to arrive instantly.
After the broker received a new message from clientN, (<code>clientN_out-&gt;current_id != last_message-&gt;message_id</code>) the broker copies the message content to its own broadcast shared memory.</p>
<p>The clients periodically, for example after finishing <code>n</code> mutations, check for new incoming messages by checking if (<code>current_broadcast_map-&gt;current_id != last_message-&gt;message_id</code>).
While the broker uses the same EOP mechanism to map new <code>ShMem</code>s for its outgoing map, it never unmaps old pages.
This additional memory resources serve a good purpose: by keeping all broadcast pages around, we make sure that new clients can join in on a fuzzing campaign at a later point in time.
They just need to re-read all broadcasted messages from start to finish.</p>
<p>So the outgoing messages flow is like this over the outgoing broadcast <code>Shmem</code>:</p>
<pre><code class="language-text">[broker]
  |
[current_broadcast_shmem]
  |
  |___________________________________
  |_________________                  \
  |                 \                  \
  |                  |                  |
 \|/                \|/                \|/
[client0]        [client1]    ...    [clientN]
</code></pre>
<p>To use <code>LLMP</code> in LibAFL, you usually want to use an <code>LlmpEventManager</code> or its restarting variant.
They are the default if using LibAFL's <code>Launcher</code>.</p>
<p>If you should want to use <code>LLMP</code> in its raw form, without any <code>LibAFL</code> abstractions, take a look at the <code>llmp_test</code> example in <a href="https://github.com/AFLplusplus/LibAFL/blob/main/libafl/examples/llmp_test/main.rs">./libafl/examples</a>.
You can run the example using <code>cargo run --example llmp_test</code> with the appropriate modes, as indicated by its help output.
First, you will have to create a broker using <code>LlmpBroker::new()</code>.
Then, create some <code>LlmpClient``s</code> in other threads and register them with the main thread using <code>LlmpBroker::register_client</code>.
Finally, call <code>LlmpBroker::loop_forever()</code>.</p>
<h3 id="b2b-connecting-fuzzers-via-tcp"><a class="header" href="#b2b-connecting-fuzzers-via-tcp">B2B: Connecting Fuzzers via TCP</a></h3>
<p>For <code>broker2broker</code> communication, all broadcast messages are additionally forwarded via network sockets.
To facilitate this, we spawn an additional client thread in the broker, that reads the broadcast shared memory, just like any other client would.
For broker2broker communication, this b2b client listens for TCP connections from other, remote brokers.
It keeps a pool of open sockets to other, remote, b2b brokers around at any time.
When receiving a new message on the local broker shared memory, the b2b client will forward it to all connected remote brokers via TCP.
Additionally, the broker can receive messages from all connected (remote) brokers, and forward them to the local broker over a client <code>ShMem</code>.</p>
<p>As a sidenote, the tcp listener used for b2b communication is also used for an initial handshake when a new client tries to connect to a broker locally, simply exchanging the initial <code>ShMem</code> descriptions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawning-instances"><a class="header" href="#spawning-instances">Spawning Instances</a></h1>
<p>Multiple fuzzer instances can be spawned using different ways.</p>
<h2 id="manually-via-a-tcp-port"><a class="header" href="#manually-via-a-tcp-port">Manually, via a TCP port</a></h2>
<p>The straightforward way to do Multi-Threading is to use the <a href="https://docs.rs/libafl/latest/libafl/events/llmp/struct.LlmpRestartingEventManager.html"><code>LlmpRestartingEventManager</code></a>, specifically to use <a href="https://docs.rs/libafl/latest/libafl/events/llmp/fn.setup_restarting_mgr_std.html"><code>setup_restarting_mgr_std</code></a>.
It abstracts away all the pesky details about restarts on crash handling (for in-memory fuzzers) and multi-threading.
With it, every instance you launch manually tries to connect to a TCP port on the local machine.</p>
<p>If the port is not yet bound, this instance becomes the broker, binding itself to the port to await new clients.</p>
<p>If the port is already bound, the EventManager will try to connect to it.
The instance becomes a client and can now communicate with all other nodes.</p>
<p>Launching nodes manually has the benefit that you can have multiple nodes with different configurations, such as clients fuzzing with and without `ASan``.</p>
<p>While it's called &quot;restarting&quot; manager, it uses <code>fork</code> on Unix-like operating systems as optimization and only actually restarts from scratch on Windows.</p>
<h2 id="automated-with-launcher"><a class="header" href="#automated-with-launcher">Automated, with Launcher</a></h2>
<p>The Launcher is the lazy way to do multiprocessing.
You can use the Launcher builder to create a fuzzer that spawns multiple nodes with one click, all using restarting event managers and the same configuration.</p>
<p>To use launcher, first you need to write an anonymous function <code>let mut run_client = |state: Option&lt;_&gt;, mut mgr, _core_id|{}</code>, which uses three parameters to create an individual fuzzer. Then you can specify the <code>shmem_provider</code>,<code>broker_port</code>,<code>monitor</code>,<code>cores</code> and other stuff through <code>Launcher::builder()</code>:</p>
<pre><code class="language-rust ignore">    Launcher::builder()
        .configuration(EventConfig::from_name(&amp;configuration))
        .shmem_provider(shmem_provider)
        .monitor(mon)
        .run_client(&amp;mut run_client)
        .cores(cores)
        .broker_port(broker_port)
        .stdout_file(stdout_file)
        .remote_broker_addr(broker_addr)
        .build()
        .launch()
</code></pre>
<p>This first starts a broker, then spawns <code>n</code> clients, according to the value passed to <code>cores</code>.
The value is a string indicating the cores to bind to, for example, <code>0,2,5</code> or <code>0-3</code>.
For each client, <code>run_client</code> will be called.
If the launcher uses <code>fork</code>, it will hide child output, unless the settings indicate otherwise, or the <code>LIBAFL_DEBUG_OUTPUT</code> env variable is set.
On Windows, the Launcher will restart each client, while on Unix-alikes, it will use <code>fork</code>.</p>
<p>Advanced use-cases:</p>
<ol>
<li>To connect multiple nodes together via TCP, you can use the <code>remote_broker_addr</code>. this requires the <code>llmp_bind_public</code> compile-time feature for <code>LibAFL</code>.</li>
<li>To use multiple launchers for individual configurations, you can set <code>spawn_broker</code> to <code>false</code> on all instances but one.</li>
<li>Launcher will not select the cores automatically, so you need to specify the <code>cores</code> that you want.</li>
<li>On <code>Unix</code>, you can chose between a forking and non-forking version of Launcher by setting the <code>fork</code> feature in LibAFL. Some targets may not like forking, but it is faster than restarting processes from scratch. Windows will never fork.</li>
<li>For simple debugging, first set the <code>LIBAFL_DEBUG_OUTPUT</code> env variable to see if a child process printed anything.</li>
<li>For further debugging of fuzzer failures, it may make sense to replace <code>Launcher</code> temporarily with a <a href="https://docs.rs/libafl/latest/libafl/events/simple/struct.SimpleEventManager.html#method.new"><code>SimpleEventManager</code></a> and call your harness fn (<code>run_client(None, mgr, 0);</code>) directly, so that fuzzing runs in the same thread and is easier to debug, before moving back to <code>Launcher</code> after the bugfix.</li>
</ol>
<p>For more examples, you can check out <code>qemu_launcher</code> and <code>libfuzzer_libpng_launcher</code> in <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers"><code>./fuzzers/</code></a>.</p>
<h2 id="other-ways"><a class="header" href="#other-ways">Other ways</a></h2>
<p>The <code>LlmpEventManager</code> family is the easiest way to spawn instances, but for obscure targets, you may need to come up with other solutions.
LLMP is even, in theory, <code>no_std</code> compatible, and even completely different EventManagers can be used for message passing.
If you are in this situation, please either read through the current implementations and/or reach out to us.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configurations"><a class="header" href="#configurations">Configurations</a></h1>
<p>Configurations for individual fuzzer nodes are relevant for multi node fuzzing.
The chapter describes how to run nodes with different configurations
in one fuzzing cluster.
This allows, for example, a node compiled with ASan, to know that it needs to rerun new testcases for a node without ASan, while the same binary/configuration does not.</p>
<p>Fuzzers with the same configuration can exchange Observers for new testcases and reuse them without rerunning the input.
A different configuration indicates, that only the raw input can be exchanged, it must be rerun on the other node to capture relevant observations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>In this chapter, we will build a custom fuzzer using the <a href="https://github.com/microsoft/lain">Lain</a> mutator in Rust.</p>
<p>This tutorial will introduce you to writing extensions to LibAFL like Feedbacks and Testcase's metadata.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<blockquote>
<h2 id="under-construction"><a class="header" href="#under-construction">Under Construction!</a></h2>
<p>This section is under construction.
Please check back later (or open a PR)</p>
<p>In the meantime, find the final Lain-based fuzzer in <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/tutorial">the fuzzers folder</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<p>In addition to core building blocks for fuzzers, LibAFL also has features for more advanced/niche fuzzing techniques.
The following sections are dedicated to some of these features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-only-fuzzing-with-frida"><a class="header" href="#binary-only-fuzzing-with-frida">Binary-only Fuzzing with Frida</a></h1>
<p>LibAFL supports different instrumentation engines for binary-only fuzzing.
A potent cross-platform (Windows, MacOS, Android, Linux, iOS) option for binary-only fuzzing is Frida; the dynamic instrumentation tool.</p>
<p>In this section, we will talk about the components in fuzzing with <code>libafl_frida</code>.
You can take a look at a working example in our <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/frida_libpng"><code>fuzzers/frida_libpng</code></a> folder for Linux, and <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/frida_gdiplus"><code>fuzzers/frida_gdiplus</code></a> for Windows.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>If you are on Linux or OSX, you'll need <a href="https://libcxx.llvm.org/">libc++</a> for <code>libafl_frida</code> in addition to libafl's dependencies.
If you are on Windows, you'll need to install llvm tools.</p>
<h2 id="harness--instrumentation"><a class="header" href="#harness--instrumentation">Harness &amp; Instrumentation</a></h2>
<p>LibAFL uses Frida's <a href="https://frida.re/docs/stalker/"><strong>Stalker</strong></a> to trace the execution of your program and instrument your harness.
Thus, you have to compile your harness to a dynamic library. Frida instruments your PUT after dynamically loading it.</p>
<p>In our <code>frida_libpng</code> example, we load the dynamic library and find the symbol to harness as follows:</p>
<pre><code class="language-rust ignore">        let lib = libloading::Library::new(module_name).unwrap();
        let target_func: libloading::Symbol&lt;
            unsafe extern &quot;C&quot; fn(data: *const u8, size: usize) -&gt; i32,
        &gt; = lib.get(symbol_name.as_bytes()).unwrap();
</code></pre>
<h2 id="fridainstrumentationhelper-and-runtimes"><a class="header" href="#fridainstrumentationhelper-and-runtimes"><code>FridaInstrumentationHelper</code> and Runtimes</a></h2>
<p>To use functionalities that Frida offers, we'll first need to obtain a <code>Gum</code> object by <code>Gum::obtain()</code>.</p>
<p>In LibAFL, we use the <code>FridaInstrumentationHelper</code> struct to manage frida-related state. <code>FridaInstrumentationHelper</code> is a key component that sets up the <a href="https://frida.re/docs/stalker/#transformer"><strong>Transformer</strong></a> that is used to generate the instrumented code. It also initializes the <code>Runtimes</code> that offer various instrumentations.</p>
<p>We have <code>CoverageRuntime</code> that can track the edge coverage,  <code>AsanRuntime</code> for address sanitizer, <code>DrCovRuntime</code> that uses <a href="https://dynamorio.org/page_drcov.html"><strong>DrCov</strong></a> for coverage collection (to be imported in coverage tools like Lighthouse, bncov, dragondance,...), and <code>CmpLogRuntime</code> for cmplog instrumentation.
All of these runtimes can be slotted into <code>FridaInstrumentationHelper</code> at build time.</p>
<p>Combined with any <code>Runtime</code> you'd like to use, you can initialize the <code>FridaInstrumentationHelper</code> like this:</p>
<pre><code class="language-rust ignore">
        let gum = Gum::obtain();
        let frida_options = FridaOptions::parse_env_options();
        let coverage = CoverageRuntime::new();
        let mut frida_helper = FridaInstrumentationHelper::new(
            &amp;gum,
            &amp;frida_options,
            module_name,
            modules_to_instrument,
            tuple_list!(coverage),
        );
</code></pre>
<h2 id="running-the-fuzzer"><a class="header" href="#running-the-fuzzer">Running the Fuzzer</a></h2>
<p>After setting up the <code>FridaInstrumentationHelper</code> you can obtain the pointer to the coverage map by calling <code>map_mut_ptr()</code>.</p>
<pre><code class="language-rust ignore">        let edges_observer = HitcountsMapObserver::new(StdMapObserver::from_mut_ptr(
            &quot;edges&quot;,
            frida_helper.map_mut_ptr().unwrap(),
            MAP_SIZE,
        ));
</code></pre>
<p>You can then link this observer to <code>FridaInProcessExecutor</code> as follows:</p>
<pre><code class="language-rust ignore">        let mut executor = FridaInProcessExecutor::new(
            &amp;gum,
            InProcessExecutor::new(
                &amp;mut frida_harness,
                tuple_list!(
                    edges_observer,
                    time_observer,
                    AsanErrorsObserver::new(&amp;ASAN_ERRORS)
                ),
                &amp;mut fuzzer,
                &amp;mut state,
                &amp;mut mgr,
            )?,
            &amp;mut frida_helper,
        );
</code></pre>
<p>And finally you can run the fuzzer.
See the <code>frida_</code> examples in <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/"><code>./fuzzers</code></a> for more information and, for linux or full-system, play around with <code>libafl_qemu</code>, another binary-only tracer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concolic-tracing-and-hybrid-fuzzing"><a class="header" href="#concolic-tracing-and-hybrid-fuzzing">Concolic Tracing and Hybrid Fuzzing</a></h1>
<p>LibAFL has support for concolic tracing based on the <a href="https://github.com/eurecom-s3/symcc">SymCC</a> instrumenting compiler.</p>
<p>For those uninitiated, the following text attempts to describe concolic tracing from the ground up using an example.
Then, we'll go through the relationship of SymCC and LibAFL concolic tracing.
Finally, we'll walk through building a basic hybrid fuzzer using LibAFL.</p>
<h2 id="concolic-tracing-by-example"><a class="header" href="#concolic-tracing-by-example">Concolic Tracing by Example</a></h2>
<p>Suppose you want to fuzz the following program:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn target(input: &amp;[u8]) -&gt; i32 {
    match &amp;input {
        // fictitious crashing input
        &amp;[1, 3, 3, 7] =&gt; 1337,
        // standard error handling code
        &amp;[] =&gt; -1,
        // representative of normal execution
        _ =&gt; 0 
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A simple coverage-maximizing fuzzer that generates new inputs somewhat randomly will have a hard time finding an input that triggers the fictitious crashing input.
Many techniques have been proposed to make fuzzing less random and more directly attempt to mutate the input to flip specific branches, such as the ones involved in crashing the above program.</p>
<p>Concolic tracing allows us to construct an input that exercises a new path in the program (such as the crashing one in the example) <strong>analytically</strong> instead of <strong>stochastically</strong> (ie. guessing).
In principle, concolic tracing works by observing all executed instructions in an execution of the program that depend on the input.
To understand what this entails, we'll run an example with the above program.</p>
<p>First, we'll simplify the program to simple if-then-else-statements:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn target(input: &amp;[u8]) -&gt; i32 {
    if input.len() == 4 {
        if input[0] == 1 {
            if input[1] == 3 {
                if input[2] == 3 {
                    if input[3] == 7 {
                        return 1337;
                    } else {
                        return 0;
                    }
                } else {
                    return 0;
                }
            } else {
                return 0;
            }
        } else {
            return 0;
        }
    } else {
        if input.len() == 0 {
            return -1;
        } else {
            return 0;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, we'll trace the program on the input <code>[]</code>.
The trace would look like this:</p>
<pre><code class="language-rust ignore">Branch { // if input.len() == 4
    condition: Equals { 
        left: Variable { name: &quot;input_len&quot; }, 
        right: Integer { value: 4 } 
    }, 
    taken: false // This condition turned out to be false...
}
Branch { // if input.len() == 0
    condition: Equals { 
        left: Variable { name: &quot;input_len&quot; }, 
        right: Integer { value: 0 } 
    }, 
    taken: true // This condition turned out to be true!
}
</code></pre>
<p>Using this trace, we can easily deduce that we can force the program to take a different path by having an input of length 4 or having an input with non-zero length.
We do this by negating each branch condition and analytically solving the resulting 'expression'.
In fact, we can create these expressions for any computation and give them to an <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>-Solver that will generate an input that satisfies the expression (as long as such an input exists).</p>
<p>In hybrid fuzzing, we combine this tracing + solving approach with more traditional fuzzing techniques.</p>
<h2 id="concolic-tracing-in-libafl-symcc-and-symqemu"><a class="header" href="#concolic-tracing-in-libafl-symcc-and-symqemu">Concolic Tracing in LibAFL, SymCC and SymQEMU</a></h2>
<p>The concolic tracing support in LibAFL is implemented using SymCC.
SymCC is a compiler plugin for clang that can be used as a drop-in replacement for a normal C or C++ compiler.
SymCC will instrument the compiled code with callbacks into a runtime that can be supplied by the user.
These callbacks allow the runtime to construct a trace that is similar to the previous example.</p>
<h3 id="symcc-and-its-runtimes"><a class="header" href="#symcc-and-its-runtimes">SymCC and its Runtimes</a></h3>
<p>SymCC ships with 2 runtimes:</p>
<ul>
<li>A 'simple' runtime that attempts to negate and analytically solve any branch conditions it comes across using <a href="https://github.com/Z3Prover/z3/wiki">Z3</a> and</li>
<li>A <a href="https://github.com/sslab-gatech/qsym">QSym</a>-based runtime, which does a bit more filtering on the expressions and also solves them using Z3.</li>
</ul>
<p>The integration with LibAFL, however, requires you to <strong>BYORT</strong> (<em>bring your own runtime</em>) using the <a href="https://docs.rs/symcc_runtime/0.1/symcc_runtime"><code>symcc_runtime</code></a> crate.
This crate allows you to easily build a custom runtime out of the built-in building blocks or create entirely new runtimes with full flexibility.
Check out the <code>symcc_runtime</code> docs for more information on how to build your own runtime.</p>
<h3 id="symqemu"><a class="header" href="#symqemu">SymQEMU</a></h3>
<p><a href="https://github.com/eurecom-s3/symqemu">SymQEMU</a> is a sibling project to SymCC.
Instead of instrumenting the target at compile-time, it inserts instrumentation via dynamic binary translation, building on top of the <a href="https://www.qemu.org"><code>QEMU</code></a> emulation stack.
This means that using SymQEMU, any (x86) binary can be traced without the need to build in instrumentation ahead of time.
The <code>symcc_runtime</code> crate supports this use case and runtimes built with <code>symcc_runtime</code> also work with SymQEMU.</p>
<h2 id="hybrid-fuzzing-in-libafl"><a class="header" href="#hybrid-fuzzing-in-libafl">Hybrid Fuzzing in LibAFL</a></h2>
<p>The LibAFL repository contains an <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/libfuzzer_stb_image_concolic">example hybrid fuzzer</a>.</p>
<p>There are three main steps involved with building a hybrid fuzzer using LibAFL:</p>
<ol>
<li>Building a runtime,</li>
<li>choosing an instrumentation method and</li>
<li>building the fuzzer.</li>
</ol>
<p>Note that the order of these steps is important.
For example, we need to have a runtime ready before we can do instrumentation with SymCC.</p>
<h3 id="building-a-runtime"><a class="header" href="#building-a-runtime">Building a Runtime</a></h3>
<p>Building a custom runtime can be done easily using the <code>symcc_runtime</code> crate.
Note, that a custom runtime is a separate shared object file, which means that we need a separate crate for our runtime.
Check out the <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/libfuzzer_stb_image_concolic/runtime">example hybrid fuzzer's runtime</a> and the <a href="https://docs.rs/symcc_runtime/0.1/symcc_runtime"><code>symcc_runtime</code> docs</a> for inspiration.</p>
<h3 id="instrumentation"><a class="header" href="#instrumentation">Instrumentation</a></h3>
<p>There are two main instrumentation methods to make use of concolic tracing in LibAFL:</p>
<ul>
<li>Using a <strong>compile-time</strong> instrumented target with <strong>SymCC</strong>.
This only works when the source is available for the target and the target is reasonably easy to build using the SymCC compiler wrapper.</li>
<li>Using <strong>SymQEMU</strong> to dynamically instrument the target at <strong>runtime</strong>.
This avoids building a separate instrumented target with concolic tracing instrumentation and so does not require source code.</li>
</ul>
<p>It should be noted, however, that the 'quality' of the generated expressions can be significantly worse and SymQEMU generally produces significantly more and significantly more convoluted expressions than SymCC.
Therefore, it is recommended to use SymCC over SymQEMU when possible.</p>
<h4 id="using-symcc"><a class="header" href="#using-symcc">Using SymCC</a></h4>
<p>The target needs to be instrumented ahead of fuzzing using SymCC.
How exactly this is done does not matter.
However, the SymCC compiler needs to be made aware of the location of the runtime that it should instrument against.
This is done by setting the <code>SYMCC_RUNTIME_DIR</code> environment variable to the directory which contains the runtime (typically the <code>target/(debug|release)</code> folder of your runtime crate).</p>
<p>The example hybrid fuzzer instruments the target in its <a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/libfuzzer_stb_image_concolic/fuzzer/build.rs#L50"><code>build.rs</code> build script</a>.
It does this by cloning and building a copy of SymCC and then using this version to instrument the target.
The <a href="https://docs.rs/symcc_libafl"><code>symcc_libafl</code> crate</a> contains helper functions for cloning and building SymCC.</p>
<p>Make sure you satisfy the <a href="https://github.com/eurecom-s3/symcc#readme">build requirements</a> of SymCC before attempting to build it.</p>
<h4 id="using-symqemu"><a class="header" href="#using-symqemu">Using SymQEMU</a></h4>
<p>Build SymQEMU according to its <a href="https://github.com/eurecom-s3/symqemu#readme">build instructions</a>.
By default, SymQEMU looks for the runtime in a sibling directory.
Since we don't have a runtime there, we need to explicitly set the <code>--symcc-build</code> argument of the <code>configure</code> script to the path of your runtime.</p>
<h3 id="building-the-fuzzer"><a class="header" href="#building-the-fuzzer">Building the Fuzzer</a></h3>
<p>No matter the instrumentation method, the interface between the fuzzer and the instrumented target should now be consistent.
The only difference between using SymCC and SymQEMU should be the binary that represents the target:
In the case of SymCC it will be the binary that was build with instrumentation and with SymQEMU it will be the emulator binary (eg. <code>x86_64-linux-user/symqemu-x86_64</code>), followed by your uninstrumented target binary and its arguments.</p>
<p>You can use the <a href="https://docs.rs/libafl/0.6.0/libafl/executors/command/struct.CommandExecutor.html"><code>CommandExecutor</code></a> to execute your target (<a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/libfuzzer_stb_image_concolic/fuzzer/src/main.rs#L244">example</a>).
When configuring the command, make sure you pass the <code>SYMCC_INPUT_FILE</code> environment variable (set to the input file path), if your target reads input from a file (instead of standard input).</p>
<h4 id="serialization-and-solving"><a class="header" href="#serialization-and-solving">Serialization and Solving</a></h4>
<p>While it is perfectly possible to build a custom runtime that also performs the solving step of hybrid fuzzing in the context of the target process, the intended use of the LibAFL concolic tracing support is to serialize the (filtered and pre-processed) branch conditions using the <a href="https://docs.rs/symcc_runtime/0.1/symcc_runtime/tracing/struct.TracingRuntime.html"><code>TracingRuntime</code></a>.
This serialized representation can be deserialized in the fuzzer process for solving using a <a href="https://docs.rs/libafl/0.6.0/libafl/observers/concolic/struct.ConcolicObserver.html"><code>ConcolicObserver</code></a> wrapped in a <a href="https://docs.rs/libafl/0.6.0/libafl/stages/concolic/struct.ConcolicTracingStage.html"><code>ConcolicTracingStage</code></a>, which will attach a <a href="https://docs.rs/libafl/0.6.0/libafl/observers/concolic/struct.ConcolicMetadata.html"><code>ConcolicMetadata</code></a> to every <a href="https://docs.rs/libafl/0.6.0/libafl/corpus/testcase/struct.Testcase.html"><code>TestCase</code></a>.</p>
<p>The <code>ConcolicMetadata</code> can be used to replay the concolic trace and to solve the conditions using an SMT-Solver.
Most use-cases involving concolic tracing, however, will need to define some policy around which branches they want to solve.
The <a href="https://docs.rs/libafl/0.6.0//libafl/stages/concolic/struct.SimpleConcolicMutationalStage.html"><code>SimpleConcolicMutationalStage</code></a> can be used for testing purposes.
It will attempt to solve all branches, like the original simple backend from SymCC, using Z3.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>The example fuzzer shows how to use the <a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/libfuzzer_stb_image_concolic/fuzzer/src/main.rs#L222"><code>ConcolicTracingStage</code> together with the <code>SimpleConcolicMutationalStage</code></a> to build a basic hybrid fuzzer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-libafl-in-no_std-environments"><a class="header" href="#using-libafl-in-no_std-environments">Using LibAFL in <code>no_std</code> environments</a></h1>
<p>It is possible to use LibAFL in <code>no_std</code> environments e.g. on custom platforms like microcontrollers, kernels, hypervisors, and more.</p>
<p>You can simply add LibAFL to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">libafl = { path = &quot;path/to/libafl/&quot;, default-features = false}
</code></pre>
<p>Then build your project e.g. for <code>aarch64-unknown-none</code> using:</p>
<pre><code class="language-sh">cargo build --no-default-features --target aarch64-unknown-none
</code></pre>
<h2 id="use-custom-timing"><a class="header" href="#use-custom-timing">Use custom timing</a></h2>
<p>The minimum amount of support LibAFL needs for a <code>no_std</code> environment is a monotonically increasing timestamp.
For this, anywhere in your project you need to implement the <code>external_current_millis</code> function, which returns the current time in milliseconds.</p>
<pre><code class="language-c">// Assume this a clock source from a custom stdlib, which you want to use, which returns current time in seconds.
int my_real_seconds(void)
{
    return *CLOCK;
}
</code></pre>
<p>Here, we use it in Rust. <code>external_current_millis</code> is then called from LibAFL.
Note that it needs to be <code>no_mangle</code> in order to get picked up by LibAFL at linktime:</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn external_current_millis() -&gt; u64 {
    unsafe { my_real_seconds()*1000 }
}
</code></pre>
<p>See <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/baby_no_std">./fuzzers/baby_no_std</a> for an example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snapshot-fuzzing-in-nyx"><a class="header" href="#snapshot-fuzzing-in-nyx">Snapshot Fuzzing in Nyx</a></h1>
<p>NYX supports both source-based and binary-only fuzzing.</p>
<p>Currently, <code>libafl_nyx</code> only supports <a href="https://github.com/AFLplusplus/AFLplusplus">afl++</a>'s instruction type. To install it, you can use <code>sudo apt install aflplusplus</code>. Or compile from the source:</p>
<pre><code class="language-bash">git clone https://github.com/AFLplusplus/AFLplusplus
cd AFLplusplus
make all # this will not compile afl's additional extensions
</code></pre>
<p>Then you should compile the target with the afl++ compiler wrapper:</p>
<pre><code class="language-bash">export CC=afl-clang-fast
export CXX=afl-clang-fast++
# the following line depends on your target
./configure --enable-shared=no
make
</code></pre>
<p>For binary-only fuzzing, Nyx uses intel-PT(Intel® Processor Trace). You can find the list of supported CPUs at <a href="https://www.intel.com/content/www/us/en/support/articles/000056730/processors.html">https://www.intel.com/content/www/us/en/support/articles/000056730/processors.html</a>.</p>
<h2 id="preparing-the-nyx-working-directory"><a class="header" href="#preparing-the-nyx-working-directory">Preparing the Nyx working directory</a></h2>
<p>This step is used to pack the target into Nyx's kernel. Don't worry, we have a template shell script in our <a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/nyx_libxml2_parallel/setup_libxml2.sh">example</a>:</p>
<p>the parameter's meaning is listed below:</p>
<pre><code class="language-bash">git clone https://github.com/nyx-fuzz/packer
python3 &quot;./packer/packer/nyx_packer.py&quot; \
    ./libxml2/xmllint \   # your target binary
    /tmp/nyx_libxml2 \    # the nyx work directory
    afl \                 # instruction type
    instrumentation \
    -args &quot;/tmp/input&quot; \  # the args of the program, means that we will run `xmllint /tmp/input` in each run.
    -file &quot;/tmp/input&quot; \  # the input will be generated in `/tmp/input`. If no `--file`, then input will be passed through stdin
    --fast_reload_mode \
    --purge || exit
</code></pre>
<p>Then, you can generate the config file:</p>
<pre><code class="language-bash">python3 ./packer/packer/nyx_config_gen.py /tmp/nyx_libxml2/ Kernel || exit
</code></pre>
<h2 id="standalone-fuzzing"><a class="header" href="#standalone-fuzzing">Standalone fuzzing</a></h2>
<p>In the <a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/nyx_libxml2_standalone/src/main.rs">example fuzzer</a> you first need to run <code>./setup_libxml2.sh</code>. It will prepare your target and create your nyx work directory in <code>/tmp/libxml2</code>. After that, you can start to write your code.</p>
<p>First, to create <code>Nyxhelper</code>:</p>
<pre><code class="language-rust ignore">let share_dir = Path::new(&quot;/tmp/nyx_libxml2/&quot;);
let cpu_id = 0; // use first cpu
let parallel_mode = false; // close parallel_mode
let mut helper = NyxHelper::new(share_dir, cpu_id, true, parallel_mode, None).unwrap(); // we don't need to set the last parameter in standalone mode, we just use None, here
</code></pre>
<p>Then, fetch <code>trace_bits</code>, create an observer and the <code>NyxExecutor</code>:</p>
<pre><code class="language-rust ignore">let observer = unsafe { StdMapObserver::from_mut_ptr(&quot;trace&quot;, helper.trace_bits, helper.map_size) };
let mut executor = NyxExecutor::new(&amp;mut helper, tuple_list!(observer)).unwrap();
</code></pre>
<p>Finally, use them normally and pass them into <code>fuzzer.fuzz_loop(&amp;mut stages, &amp;mut executor, &amp;mut state, &amp;mut mgr)</code> to start fuzzing.</p>
<h2 id="parallel-fuzzing"><a class="header" href="#parallel-fuzzing">Parallel fuzzing</a></h2>
<p>In the <a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/nyx_libxml2_parallel/src/main.rs">example fuzzer</a> you first need to run <code>./setup_libxml2.sh</code> as described before.</p>
<p>Parallel fuzzing relies on <a href="advanced_features/../message_passing/spawn_instances.html"><code>Launcher</code></a>, so spawn logic should be written in the scoop of anonymous function <code>run_client</code>:</p>
<pre><code class="language-rust ignore">let mut run_client = |state: Option&lt;_&gt;, mut restarting_mgr, _core_id: usize| {}
</code></pre>
<p>In <code>run_client</code>, you need to create <code>NyxHelper</code> first:</p>
<pre><code class="language-rust ignore">let share_dir = Path::new(&quot;/tmp/nyx_libxml2/&quot;);
let cpu_id = _core_id as u32;
let parallel_mode = true;
let mut helper = NyxHelper::new(
    share_dir, // nyx work directory
    cpu_id,    // current cpu id
    true,      // open snap_mode
    parallel_mode, // open parallel mode
    Some(parent_cpu_id.id as u32), // the cpu-id of main instance, there is only one main instance, other instances will be treated as secondaries
)
.unwrap();
</code></pre>
<p>Then you can fetch the trace_bits and create an observer and <code>NyxExecutor</code></p>
<pre><code class="language-rust ignore">let observer = unsafe { StdMapObserver::from_mut_ptr(&quot;trace&quot;, helper.trace_bits, helper.map_size) }
let mut executor = NyxExecutor::new(&amp;mut helper, tuple_list!(observer)).unwrap();
</code></pre>
<p>Finally, open a <code>Launcher</code> as usual to start fuzzing:</p>
<pre><code class="language-rust ignore">match Launcher::builder()
    .shmem_provider(shmem_provider)
    .configuration(EventConfig::from_name(&quot;default&quot;))
    .monitor(monitor)
    .run_client(&amp;mut run_client)
    .cores(&amp;cores)
    .broker_port(broker_port)
    // .stdout_file(Some(&quot;/dev/null&quot;))
    .build()
    .launch()
{
    Ok(()) =&gt; (),
    Err(Error::ShuttingDown) =&gt; println!(&quot;Fuzzing stopped by user. Good bye.&quot;),
    Err(err) =&gt; panic!(&quot;Failed to run launcher: {err:?}&quot;),
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
